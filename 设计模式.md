## 设计模式



### 创建型模式

#### 工厂模式

##### 特点

最常用的设计模式。

定义一个创建对象的接口，让工厂类根据传入的参量决定创建出哪一种产品类的实例

##### 优点

增加产品时只需要新扩展一个工厂类就可以，增加对象时只需要知道名称就可以

##### 场景

+ 日志记录器，可选择记录到哪个位置。
+ 连接服务器时，可将几个协议作为产品类，共同实现一个接口



#### 抽象工厂模式

##### 特点

围绕一个中心工厂，创建别的小工厂。

提供一个接口，用于创建一系列相关的接口，而无需指定具体的类

##### 优点：

产品族中的多个对象被组合在一起工作时，保证客户端只使用同一个产品族中的对象

##### 使用场景

+ 属于同一产品族的一系列相关产品对象一起创建时，可以避免大量重复代码。

+ 提供一个产品类的库，所有的产品以同样的接口出现





#### 单例模式

##### 特点

保证一个类只有一个实例，并提供一个全局访问点。

保证内容的一致性。

##### 优点

+ 无需每次创建实例，减少内存开销
+ 避免对资源的重复占用

##### 场景

+ 任务管理器
+ 打印机、回收站等
+ 需要被共享的场合可以使用单例模式，节省内存且加快访问速度





### 行为型模式

#### 策略模式

##### 特点

定义算法群，一个类的行为随着给出策略的变化而更改。



##### 优点

+ 避免了大量 if···else 的冗杂结构
+ 算法可以自由切换，只需变换相应的策略
+ 扩展性良好



##### 场景

+ 需要动态选择几种算法中的一种
+ 有很多相似的类，只有行为不一样
+ 一个对象有很多的行为



**注意** ：一个系统的策略多于四个需使用混合模式，解决策略类膨胀问题



#### 模板模式

（个人理解）多态的运用

##### 特点

定义一个算法的骨架，然后一些步骤延迟到子类实现。

可以达到子类在不改变算法结构的情况下，重新定义算法中的某些步骤。



##### 优点

+ 提取公共部分，便于维护
+ 行为由父类控制，由子类来实现



##### 场景

+ 重要、复杂的方法可以作为模板来使用



#### 观察者模式

##### 特点

一对多的关系可以使用该模式。 当一个对象被修改时，会自动通知依赖它的所有对象们。

##### 优点

+ 降低了目标与观察者之间的耦合关系
+ 符合”开闭原则“

#####  场景

+ 一个对象必须通知其他对象，而并不知道这些对象是谁。

+ 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变























































