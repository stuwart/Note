## Java语言



```java
public class HelloWorld{
    public static void main(String[] args){
        System.out.println("Hello,World!");
    }
}
```

Javac:：JDK提供的编译工具，可将java文件编译成class文件。

java：运行当前路径下编译好的class文件。

### 分类

+ JavaME：主要用于嵌入式开发
+ JavaSE：主要用于桌面软件开发
+ JavaEE：主要用于分布式网站开发



### 基础语法与函数

#### 输入

```java
Scanner sc = new Scanner(System.in);
int a = scanner.nextInt();
```

#### 随机数

```java
 Random r = new Random();
 int number = r.nextInt(10);
```







### 数组

#### 静态定义

```java
int[] a = {1,2,3};  //数量和元素内容已定好

int [] a = new int[]{11,22,3} //完整格式
```



#### 动态定义

```java
int[] a = new int[4];
```







### 内存分配

+ **栈** ：方法运行时所进入的内存，变量也在此处
+ **堆** ：new 出来的东西会在这块内存中开辟空间并产生地址
+ **方法区**  ：字节码文件(class文件)加载时进入的内存
+ 本地方法栈
+ 寄存器





### 方法

#### 定义

完整格式：

```java
修饰符 返回值类型 方法名(形参列表){
    方法体代码
        return 返回值；
}
```

**修饰符** ： `public static`



**注意事项**：

+ 编写顺序无所谓，各方法是平等关系
+ 方法不调用就不执行，调用必须严格匹配参数情况
+ 方法之间不能嵌套定义



#### 方法调用内存

**没有被调用时：** 在方法区中的字节码文件中存放

**被调用时：** 需要进入到栈内存中运行



#### 方法重载

**定义** ：同一个类中，多个方法名相同，但是形参列表不同，称为**重载方法**

**作用** ：可读性好，方法名称相同提示是同一类型的功能，通过形参不同实现功能差异化的选择，这是一种专业的代码设计。

**识别技巧** ：

+ 只要是同一个类中，方法名称相同、形参列表不同，那么他们就是重载的方法
+ 形参列表不同指的是：形参的个数、类型、顺序不同，不关心形参的名称。





### 面向对象

**三大特征** ：封装、继承、多态





#### 类

```java
public class 类名{
    ···
}
```

+ 成员变量（代表属性，一般为名词）
+ 成员方法（代表行为，一般为动词）
+ 构造器
+ 代码块
+ 内部类





**得到类的对象** ：

```java
类名 对象名 = new 类名();
```

**使用对象** ：

```java
访问属性： 对象名.成员变量
访问行为： 对象名.方法名()
```



**注意事项**：一个Java文件中可定义多个class类，但只能有一个用public修饰



#### 构造器

**作用**：用于初始化一个类的对象，并返回对象的地址。

**格式**：

```java
public class Car{
    
    public Car(){  //无参数构造器
        
    }
    public Car(String n,double p){  //有参数构造器
        
    }
}
```

**调用构造器得到对象：**

类 变量名称 = new 构造器;

```java
Car c = new Car();

Car c1 = new Car("奔驰",666);
```



**分类和作用**

+ 无参数构造器（默认存在）：初始化对象时，成员变量均为默认值
+ 有参数构造器：初始化对象，同时接收参数为对象进行赋值



**注意事项**：

+ 任何类一旦定义出来，默认就自带了无参数构造器
+ 定义了有参数构造器后就没有了无参数构造器，需要自己手写一个无参数构造器





#### 内部类

**访问特点**

+ 内部类可以直接访问外部类的所有成员
+ 外部类必须创建对象才能访问内部类的成员

##### 分类

+ 成员内部类
+ 静态内部类
+ 局部内部类
+ 匿名内部类







#### 关键字

##### this

+ 可以出现在构造器、方法中，**代表当前对象的地址**
+ 作用：访问当前对象的成员变量、成员方法



##### super

通过super来实现对父类成员的访问，来引用当前对象的父类



##### final

用来修饰变量，方法和类

+ 变量：表明该变量第一次被赋值后，不能再次被赋值
+ 方法：表明该方法为最终方法，不能被重写
+ 类：表明该类是最终类，不能被继承

**注意**

+ 修饰的变量是基本数据类型：内容不能改变
+ 修饰的变量是引用数据类型：地址不能改变，内容可以改变





##### static

静态修饰符

+ 修饰变量：在内存中之存储一份，可以被共享访问、修改



**注意**

+ 静态方法只能访问静态的成员，不可以直接访问实例成员
+ 实例方法可以访问静态成员，也可以访问实例成员
+ 静态方法中不能出现 `this`



**静态代码块** ：

+ 启动系统时对数据进行初始化，可使用静态代码块进行初始化



##### public static final

修饰常量，必须有初始化值，并且值不能发生改变。





#### 封装

**定义**：隐藏实现细节，暴露出合适的访问方式

**原则**：对象代表什么，就封装对应的数据，并提供数据对应的行为



##### 更好地封装：

+ 对成员变量使用 `private` 关键字修饰 ，（只能在当前类中进行访问）
+ 为每个成员变量提供配套public修饰的getter\setter方法暴露其取值和赋值



##### JavaBean

**定义** ：

+ 成员变量使用`private` 修饰
+ 提供每一个成员变量对应的 setXxx()/getXxx()
+ 必须提供一个无参构造器



##### 成员变量与局部变量区别





#### 继承

##### 格式

```java
class 父类 {
}
 
class 子类 extends 父类 {
}
```



##### 类型

+ 单继承
+ 多重继承
+ 不同类继承一个类
+ 多继承



##### 特性

+ 子类有父类非 private 的方法
+ 子类可以有自己的属性和方法，对父类进行扩展
+ 可以用自己的方式实现父类的方法（重写）
+ Java为单继承，但是可以多重继承
+ 提高了类之间的耦合性（缺点，使得代码的独立性变差）

**注意**

子类继承后默认先访问父类中的无参构造器

子类初始化前必须调用父类的构造器完成数据的初始化



##### 关键字

###### extends

`class 子类 extends 父类{`

`}`



###### implements

使用该关键字可变相使 Java 具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口

```java
public interface A {
    public void eat();
    public void sleep();
}
 
public interface B {
    public void show();
}
 
public class C implements A,B {
}
```





##### 构造器

+ 父类的无参构造器：默认自动调用
+ 父类的有参构造器：必须使用`super` 调用



#### 重写

可添加`@Override` 以便进行错误提示

子类对父类的方法进行重新编写，返回值和形参不能改变

**好处** ：可以根据需要来定制方法

**要求** ：不能抛出新的检查异常或者更多的检查异常

**规则:**

+ 参数列表必须相同
+ 返回类型可以不同， 但必须是父类返回值的派生类
+ 访问权限不能比父类中的方法权限更低
+ 父类成员方法只能被其子类重写
+ final声明的方法不能重写
+ 构造方法不能被重写
+ 在一个包中子类可重写父类的所有方法，除了`private` 和`final`
+ 不在一个包中子类只能重写父类的 `public` 和 `protected` 方法



#### 重载

- 被重载的方法必须改变参数列表(参数个数或类型不一样)；
- 被重载的方法可以改变返回类型；
- 被重载的方法可以改变访问修饰符；
- 被重载的方法可以声明新的或更广的检查异常；
- 方法能够在同一个类中或者在一个子类中被重载。
- 无法以返回值类型作为重载函数的区分标准。



#### 多态

##### 存在的必要条件

+ 继承
+ 重写
+ 父类引用 指向 子类对象



使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。

##### 实现方式

+ 重写
+ 接口
+ 抽象类和抽象方法

##### 优势

+ 对象可以解耦合，便于扩展维护







#### 抽象类与抽象方法

抽象类不能实例化对象，其他与一般类无异，只能通过继承实现抽象类。



##### 抽象方法

```java
public abstract class Employee
{
   private String name;
   private String address;
   private int number;
   
   public abstract double computePay();
   
   //其余代码
}
```



**注意** ：

+ 只有抽象类才能包含抽象方法
+ 任何子类必须重写父类的抽象方法，或者声明自身为抽象类
+ 继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类



必须有子类实现抽象方法，否则从父类到子类都不能实例化对象



**规定**

-  抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。
- 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
- 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。
- 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。
- 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。



#### 接口

+ 不是类，接口包含类要实现的方法
+ 除非是抽象类，否则该类要定义接口中的方法
+ 无法被实例化，可以被实现
+ 可用来声明一个变量





##### 特性

- 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 **public abstract**（只能是 public abstract，其他修饰符都会报错）。
- 接口中可以含有变量，但是接口中的变量会被隐式的指定为 **public static final** 变量（并且只能是 public，用 private 修饰会报编译错误）。
- 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。



- 接口是隐式抽象的，当声明一个接口的时候，不必使用**abstract**关键字。
- 接口中每一个方法也是隐式抽象的，声明时同样不需要**abstract**关键字。
- 接口中的方法都是公有的。



**注意** ：一个类继承接口必须重写所有的抽象方法，否则为抽象类





### String

java.lang.String类，定义的变量可以用于指向字符串对象，然后操作该字符串



#### 特点

被称为不可变字符串类型，对象在创建后不能被更改



#### 内存分配

以 `""`  方式给出的字符串对象，在字符串常量池中存储

字符串常量池：在堆内存中



#### 创建对象的方式

+ 直接定义： `String name = "xxx"`
+ 通过构造器定义： `String s = new String(abc)`



##### 区别

+ 以`""` 方式给出的字符串对象，在字符串常量池中存储，而且相同内容只会在其中存储一份
+ 通过构造器 new 对象，每new一次都会产生一个新对象，放在堆内存中



##### 内存原理

+ 通过 `""` 方式定义的字符串对象，在字符串常量池中存储的是同一个
+ 通过 new 方式定义的字符串对象，会开辟新的空间，在堆内存中分开存储



#### 常用API

**字符串内容比较**

equals : 只关心内容是否一致

equalsIgnoreCase：忽略大小写，只关心内容是否一致



**长度**

`public int length()`



**获取某个索引的字符**

`public char charAt(int index)`



**将字符串转换成字符数组返回**

`public char[] toCharArray()`



**截取字符串**

包前不包后

`public String substring(int beginIndex,int endIndex)`



**截取字符串**

从某个字符开始到结尾

`public String substring(int beginIndex)`



**替换某个字符**

`public String replace(CharSequence target, CharSequence replacement)` 



**切割字符串**

根据传入的规则切割，返回字符串数组

`public String[] split(String regex)`





### ArrayList

#### 特点

+ 大小、类型不固定，动态变化
+ 集合非常适合做元素个数不确定，要进行增删操作的业务场景
+ 集合提供许多API



#### 对象获取

构造器方法：

`public ArrayList()` 



添加元素方法：

`public boolean add(E e)` ：将指定的元素追加到此集合的末尾

`public void add(int index, E element)` ：将此集合中指定位置插入指定元素





#### 泛型

`ArrayList<E>` ：是一个泛型类，可以在编译阶段约束集合对象只能操作某种数据类型

使用： `Array<String> list = new ArrayList();`

**注意** ：只支持引用类型，不支持基本数据类型



#### 常用API

**返回指定索引元素**

`public E get(int intdex)` 



**返回集合中元素个数**

`public int size()`



**删除指定索引处的元素，返回该元素**

`pbulic E remove(int index)`



**删除指定的元素，返回是否成功**

`public boolean remove(Object o)`



**修改指定索引处的元素，返回该元素**

`public E set(int index, E element)`



**排序**：

+ 默认升序排序  ： `public static void sort(类型[] a)`
+ 使用比较器对象自定义排序： `public static <T>  void sort(类型[] a,Comparator<?super T> c) `





### 其他

#### 包装类

![Snipaste_2022-07-15_15-10-17.png](https://s2.loli.net/2022/07/15/xNFZe7iwQAucKJa.png)

+ 集合和泛型只支持包装类

**特点**

+ 可以把数据转化成字符串类型
+ 可以把字符串类型转化成数值



#### 正则

`public Boolean matches(String regex):` 判断是否匹配正则表达式

![Snipaste_2022-07-15_15-19-42.png](https://s2.loli.net/2022/07/15/cIAW2axs7rKDNPS.png)

**正则表达式方法应用**

![image.png](https://s2.loli.net/2022/07/15/RfFkU6a7Vdvqu4I.png)





#### Lambda

**作用** ：简化函数式接口的匿名内部类的写法

**前提**：必须是接口的匿名内部类，接口中只能有一个抽象方法



























## Maven

`mavenrepository.com`

### 结构

+ bin
+ boot
+ conf
+ lib





### 坐标

Maven中资源所在位置

+ 组织ID   `goupId` 
+ 项目ID   `artifactId`
+ 版本号   `version`

 

#### parent

`parent` 是一系列相兼容的版本组合，已经适配好，不会冲突

- 项目中的pom.xml中继承了一个坐标

```XML
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.5.4</version>
</parent>
```

- 打开后可以查阅到其中又继承了一个坐标

```XML
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-dependencies</artifactId>
    <version>2.5.4</version>
</parent>
```

这个坐标中定义了两组信息，第一组是各式各样的依赖版本号属性,第二组是各式各样的的依赖坐标信息，没有具体的版本号，引用了第一组信息中定义的版本号信息



#### starter

starter定义了使用某种技术时对于依赖的固定搭配格式，也是一种最佳解决方案

##### 

​	<font color="#ff0000"><b>starter</b></font>是一个坐标中定了若干个坐标，以前写多个的，现在写一个，<font color="#ff0000"><b>是用来减少依赖配置的书写量的</b></font>

​	<font color="#ff0000"><b>parent</b></font>是定义了几百个依赖版本号，以前写依赖需要自己手工控制版本，现在由SpringBoot统一管理，这样就不存在版本冲突了，<font color="#ff0000"><b>是用来减少依赖冲突的</b></font>



**实际开发应用方式**

- 实际开发中如果需要用什么技术，先去找有没有这个技术对应的starter

  - 如果有对应的starter，直接写starter，而且无需指定版本，版本由parent提供
  - 如果没有对应的starter，手写坐标即可

- 实际开发中如果发现坐标出现了冲突现象，确认你要使用的可行的版本号，使用手工书写的方式添加对应依赖，覆盖SpringBoot提供给我们的配置管理

  - 方式一：直接写坐标
  - 方式二：覆盖<properties>中定义的版本号，就是下面这堆东西了，哪个冲突了覆盖哪个就OK了



### 主要命令

+ `mvn compile`   ：编译
+ `mvn clean`  ：清理操作
+ `mvn test `  ：测试
+ `mvn package`   ：打包
+ `mvn install` ：安装包



### IDEA

#### 依赖配置

```xml
<project>
...
<dependencies>
    <dependency>
        <groupId>实际项目</groupId>
　　　　 <artifactId>模块</artifactId>
　　　　 <version>版本</version>
　　　　 <type>依赖类型</type>
　　　　 <scope>依赖范围</scope>
　　　　 <optional>依赖是否可选</optional>
　　　　 <!—主要用于排除传递性依赖-->
　　　　 <exclusions>
　　　　     <exclusion>
　　　　　　　    <groupId>…</groupId>
　　　　　　　　　 <artifactId>…</artifactId>
　　　　　　　</exclusion>
　　　　 </exclusions>
　　</dependency>
<dependencies>
...
</project>

```



**依赖范围**：

+ `compile`
+ `test` 
+ `provided`
+ `runtime`
+ `system` ：此时需要用`systemPath` 元素来引用环境变量

![1](https://pic.jitudisk.com/public/2022/07/14/222a97e75113f.png)













## 设计模式



### 创建型模式

#### 工厂模式

##### 特点

最常用的设计模式。

定义一个创建对象的接口，让工厂类根据传入的参量决定创建出哪一种产品类的实例

##### 优点

增加产品时只需要新扩展一个工厂类就可以，增加对象时只需要知道名称就可以

##### 场景

+ 日志记录器，可选择记录到哪个位置。
+ 连接服务器时，可将几个协议作为产品类，共同实现一个接口



#### 抽象工厂模式

##### 特点

围绕一个中心工厂，创建别的小工厂。

提供一个接口，用于创建一系列相关的接口，而无需指定具体的类

##### 优点：

产品族中的多个对象被组合在一起工作时，保证客户端只使用同一个产品族中的对象

##### 使用场景

+ 属于同一产品族的一系列相关产品对象一起创建时，可以避免大量重复代码。

+ 提供一个产品类的库，所有的产品以同样的接口出现





#### 单例模式

##### 特点

保证一个类只有一个实例，并提供一个全局访问点。

保证内容的一致性。

##### 优点

+ 无需每次创建实例，减少内存开销
+ 避免对资源的重复占用

##### 场景

+ 任务管理器
+ 打印机、回收站等
+ 需要被共享的场合可以使用单例模式，节省内存且加快访问速度





### 行为型模式

#### 策略模式

##### 特点

定义算法群，一个类的行为随着给出策略的变化而更改。



##### 优点

+ 避免了大量 if···else 的冗杂结构
+ 算法可以自由切换，只需变换相应的策略
+ 扩展性良好



##### 场景

+ 需要动态选择几种算法中的一种
+ 有很多相似的类，只有行为不一样
+ 一个对象有很多的行为



**注意** ：一个系统的策略多于四个需使用混合模式，解决策略类膨胀问题



#### 模板模式

（个人理解）多态的运用

##### 特点

定义一个算法的骨架，然后一些步骤延迟到子类实现。

可以达到子类在不改变算法结构的情况下，重新定义算法中的某些步骤。



##### 优点

+ 提取公共部分，便于维护
+ 行为由父类控制，由子类来实现



##### 场景

+ 重要、复杂的方法可以作为模板来使用



#### 观察者模式

##### 特点

一对多的关系可以使用该模式。 当一个对象被修改时，会自动通知依赖它的所有对象们。

##### 优点

+ 降低了目标与观察者之间的耦合关系
+ 符合”开闭原则“

#####  场景

+ 一个对象必须通知其他对象，而并不知道这些对象是谁。

+ 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变







## Mybatis-Plus





### 简介



































































## SpringBoot

### JWT

#### 结构

由标头`Header` ，有效载荷`Paylaod` 和签名 `Signature` 组成。传输的时候会将三部分分别用Base64编码并以`.` 连接

`JWTString = Base64(Header).Base64(Payload).HMACSHA256(base64UrlEncode(header)+"."+base64UrlEncode(payload),secret)`



由于并不安全，只是进行编码转换没有加密，所以不能将隐私信息放在JWT中。







5 6 12 13 14 15 16 17 19 23

















