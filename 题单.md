## 题单

+ [基础算法](https://www.luogu.com.cn/training/2929)
+ [拓展模板](https://www.luogu.com.cn/training/2650)  难度较大
+ [提高数据结构](https://www.luogu.com.cn/training/2649)
+ [进阶数据结构](https://www.luogu.com.cn/training/3367#information)
+ [DP基础](https://www.luogu.com.cn/training/5011)
+ [动态规划提高](https://www.luogu.com.cn/training/12927)
+ [动态规划综合](https://www.luogu.com.cn/training/1435#information)
+ [数论](https://www.luogu.com.cn/training/3135#information)
+ [图论模板](https://www.luogu.com.cn/training/3364)
+ [提高图论](https://www.luogu.com.cn/training/4969)
+ [思维题](https://www.luogu.com.cn/training/4865#problems)
+ [综合](https://www.luogu.com.cn/training/9391)



## 基础算法

### 素数筛法

#### 线性筛（最快）

时间复杂度：O(n)

```cpp
int Mark[MAXSIZE];  
int prime[MAXSIZE];  

//判断是否是一个素数  Mark 标记数组 index 素数个数  
int Prime(){  
    int index = 0;  
    for(int i = 2; i < MAXSIZE; i++){  
        //如果未标记则得到一个素数  
        if(Mark[i] == 0) prime[++index] = i;  
        //标记目前得到的素数的i倍为非素数  
        for(int j = 1; j <= index && prime[j] * i < MAXSIZE; j++){  
            Mark[i * prime[j]] = 1;  
            if(i % prime[j] == 0) break;  
        }  
    }  
    return index;  
}
```



#### 欧拉筛

**时间复杂度：O(n)**

**原理**：如果判断24是否为一个素数那么用埃氏筛的话起码会重复筛24三次（2\*12，3\*8，4\*6），那欧拉筛就是在此基础上只筛一次就是其最小质因数与因一个合数的乘积。

```cpp
#include <bits/stdc++.h>//欧拉筛

using namespace std;
bool A[100000001];
int prime[1000001];

int main() {
    int n, m;
    scanf("%d %d", &n, &m);
    int cnt = 0;
    for (int i = 2; i <= n; i++) {
        if (A[i] == false) {
            prime[++cnt] = i;
        }
        for (int j = 1; j <= cnt && i * prime[j] <= n; j++) {
            A[i * prime[j]] = true;
            if (i % prime[j] == 0) break;//最重要的一步
        }
    }
    for (int i = 0; i < m; i++) {
        int c;
        scanf("%d", &c);
        printf("%d\n", prime[c]);
    }
    return 0;
}
```



### 快速幂

最快的快速幂算法，运用了位运算大大加快运算速度。

```cpp
long long fastPower(long long base, long long power) {
    long long result = 1;
    while (power > 0) {
        if (power & 1) {//此处等价于if(power%2==1)
            result = result * base ;
        }
        power >>= 1;//此处等价于power=power/2
        base = (base * base) ;
    }
    return result;
}
```



### 矩阵快速幂

**先修知识：线性代数  （狗头）**

时间复杂度：$O(log_2k)$ 

```cpp
struct matrix
{
    int n,m;   
    int e[105][105];
}
matrix a,b;

matrix mul(matrix a,matrix b)
{
    matrix ans;
    ans.n=a.n;
    ans.m=b.m;
    
    for(int i=1;i<=ans.m;i++)
   		for(int j=1;j<=ans.m;j++)
            ans.e[i][j]=0;     //初始化
    
    for(int i=1;i<=a.n;i++)
        for(int j=1;j<=b.m;j++)
            for(int k=1;k<=a.m;k++)
                ans.e[i][j]=(ans.e[i][j]+(a.e[i][k]*b.e[k][j])%mod)%mod;//快速幂的取模就在这里了！
    return ans;
}

matrix power(matrix a,ll b)
{
    matrix ans;
    ans.n=a.n;
    ans.m=a.m;
    //初始化为单元矩阵
    for(int i=1;i<=ans.n;i++)
    	for(int j=1;j<=ans.m;j++)
            if(i==j) 
                ans.e[i][j]=1;
    		else 
                ans.e[i][j]=0;    
    
    while(b)
    {
        if(b&1)
            ans=mul(ans,a);
       	a=mul(a,a);
        b>>=1;
    }
    return ans;
}
```



### 三分法

假设题意求单峰函数的最值点，那么每次取两个点：`x = (2*l+r)/3` , `y = l+(2*r)/3` 

若只有最大值，则 分为两种情况

+ `f(x)>f(y)` ，舍弃$[y,r]$

+ `f(x)<f(y)`，舍弃$[l,x]$

![image.png](https://s2.loli.net/2022/08/15/vOA3olE6s7IFRak.png)

```cpp
while (abs(r - l) > exp) {
        double x = (2 * l + r) / 3, y = (l + 2 * r) / 3;
        if (f(x) < f(y)) {
            l = x;
        } else {
            r = y;
        }
    }
```





### 字符串算法

#### KMP

用于判断一个字符串中是否存在另一个字符串。

+ 用一个nex数组维护 最长的 前缀与后缀相同的子串（最大为 n-1 ）



#### Manacher



#### Sam



#### Pam



### ST算法

**RMQ**：区间最大值/最小值查询

#### 复杂度

预处理：`O(nlogn)`

查询：`O(1)`



#### 实现

预处理，算出每个区间之间的最值。

```cpp
void init(int x)
{
  	for(int i=1;i<=n;i++)
        st[i][0]=a[i];
  	
  	for(int j=1;(1<<j)=sizeof(a);j++)
    {
      	for(int i=1;i+(1<<(j-1))<=sizeof(a);i++)
        {
          	st[i][j] = max(st[i][j-1],st[i+(1<<(j-1))][j-1]);
        }
    }
}
```



查询

```cpp
int Log[n+7];
void getLog()
{
	Log[1] = 0;
	for(int i=2;i<=n+1;i++)
		Log[i] = Log[i/2]+1;
}

int query(int l,int r)
{
   int k = Log(r-l+1);
   ans = max(st[l][k],st[r-(1<<k)+1][k];
   return ans;
}
```



## 数据结构

### 链表

**存储线性表的数据元素，可以是不连续的**

##### 动态链表

```c++
#初始化
struct node{
    int data;
    node *next;
};

node *head, *p, *now, *prev;

head = new node;          //定义变量
head->data = 1;          //分配第一个节点，数据置为1
head->next = NULL;  //
now = head;  //当前指针为头指针
```



##### 结构体实现链表

```c++
(单向)
struct node{
    int id;
    int nextid;
}nodes[maxn];

nodes[0].nextid = 1;
for(int i=1;i<=n;i++)
{
    nodes[i].id=i;
    nodes[i].nextid = i+1;
}
nodes[n].nextid = 1;  //循环链表

```



##### STL list

list为双向链表。

```c++
初始化
list<int> l1;  //空对象
list<int> l2(3,1); //包含3个1的对象

遍历

list<int>::iterator it = l2.begin();
while(it != l2.end())
{
    *it += 1;
    cout<<*it<<' ';
    it++;
}

范围for遍历
for(auto& e:l2)
{
    cout<<e<<' ';
}

插入
l1.push_back(xx);
l1.push_front(xx);
l1.pop_front();
l1.pop_back();

insert:
auto pos = ++l1.begin();
l1.insert(pos,5); //在pos位置前加一个5
l1.insert(pos,3,5); //在pos位置前加3个5

erase:
l1.erase(pos);   //删除pos位置元素
l1.erase(++le.begin(),--l1.end());  //删除中间内容


清空：
l1.clear();

```





### 并查集

**一种树形数据结构，用于处理不交集的合并及查询问题**

#### 创建

```c
void init(int size){
    for(int i=0;i<size;i++)
    {
        fa[i]=i;
    }
}
```



#### 查找

```c
int find(int x){
    if(fa[x]==x)
        return x;
    else
        return find(fa[x]);
}

//路径压缩版本

int find(int x){
    if(fa[x]!=x)
        fa[x]=find(fa[x]);
    return fa[x];
}
```



#### 合并

```c
viod merge(int x,int y){
    x=find(x);
    y=find(y);
    fa[x]=y;
}
```



#### 启发式合并（按秩合并）

运用于： 可持久化并查集、线段树分治 + 并查集

```c
//选择点数作为估价函数

vector<int> size(N,1);  //记录并初始化子树的大小为1

void merge(int x,int y){
    int xx = find(x);
    int yy = find(y);
    if(xx == yy) return;
    if(siez[xx] > size[yy])  // 保证小的合并到大的
        swap(xx,yy);
    fa[xx]=yy;
    size[yy]+=size[xx];
}
```





### 树状数组

#### 场景

单点修改，区间查询。



#### 复杂度

时间复杂度： 查询与修改均为 $log(n)$



**根本**：

```cpp
int lowbit(int x)   //作用：找到最后一位
{
    return x&(-x);
}
```



**求前缀和** 

```cpp
int getSum(int m){
	int ans = 0;
    while(m > 0){
        ans += C[m];
        m -= lowbit(m);
    }
    return ans;
}
```



**更新**

```cpp
void update(int x, int value){
    A[x] += value;	// 修改源数组
    while(x <= n){
        C[x] += value;
        x += lowbit(x);
    }
}

```



**示意图**：

![image.png](https://s2.loli.net/2022/07/22/9QK5rJvCuyUDms7.png)













### 线段树

#### 场景

+ 单点修改、区间修改
+ 查询区间的值



#### 操作

```cpp
int t[MAXN<<2];
```



##### 建树

```cpp
void build(int k,int l,int r)
{
    if(l==r)
        t[k] = a[i];
   	else
    {
        int m = (r-l)<<1+l;
        build(k<<1,l,m);
        build(k<<|1,m+1,r);
    }
}
```

##### 点更新

```cpp
void update(int p,int v,int k,int l,int r) //点更新
{
    if(l==r)
    {
        a[k] += v;
        t[k] += v;
    }
    else{
        int m = (r - l) / 2 + l;
        if (p <= m)
        {
            update(p, v, k << 1, l, m);
        }
        else{
            update(p, v, k << 1 | 1, m + 1, r);
        }
        Pushup(k);
    }
}
```

##### 区间更新

```cpp
void Update(int L,int R,int v,int k,int l,int r) //区间更新
{
    if(L<=l && R>=r)
    {
        t[k]+=v;
        lazy[k] += v;
    }
    else
    {
        Pushdown(k);
        int m = (r - l) / 2 + l;
        if(L<=m)
        {
            Update(L, R, v, k >> 1, l, m);
        }
        if(R>m)
        {
            Update(L, R, v, k >> 1 | 1, m + 1, r);
        }
        Pushup(k);
    }
}
```

##### 区间求最值

```cpp

ll ask(int L,int R,int k,int l,int r)   //区间查询最值
{
    if(L<=l && R>=r)
        return t[k];
    else
    {
        Pushdown(k);
        ll ans = INF;
        int m = (r - l) / 2 + l;
        if(L<=m)
            ans = max(ans, ask(L, R, k << 1, l, m));
        if(R>=m+1)
            ans = max(ans, ask(L, R, k >> 1 | 1, m + 1, r));

        return ans;
    }
}

```



##### 上升

```cpp
void pushup(int k)
{
    t[k] = t[k << 1] + t[k << 1 | 1];
}
```

##### 下降

```cpp
void pushdown(int k, int l, int r)
{
    int m = (l + r) >> 1;
    if (lazy[k] != 0)
    {
        lazy[k << 1] +=lazy[k];
        lazy[k << 1 | 1] += lazy[k];
        t[k << 1] += lazy[k] * (m - l + 1);
        t[k << 1 | 1] += lazy[k] * (r - m);
        lazy[k] = 0;
    }
}
```



### 笛卡尔树



```cpp
  for(int i=1;i<=n;i++){
        a[i]=read();
        while(a[sta[top]]>a[i]&&top) son[i][0]=sta[top--];
        if(sta[top]) son[sta[top]][1]=i;
        sta[++top]=i;
    }
    for(int i=1;i<=n;i++){
        lans=lans^(i*(son[i][0]+1));
        rans=rans^(i*(son[i][1]+1));
    }
```



## 动态规划

### 暴力DP

#### 背包问题



#### 状压DP

利用二进制数表示状态，通过枚举所有状态进行动态规划。



#### 区间DP

>  区间dp就是在区间上进行**动态规划**，求解一段区间上的最优解。主要是通过合并小区间的 最优解进而得出整个大区间上最优解的dp算法。

**核心思路**：要求一个大区间中的最优解，只需要把这个很大的区间不断分割，变成很小的一个个区间，求出每个小区间的最优解，然后合并起来，最终找出完整区间的最优解即可。

```cpp
for(int len = 1;len<=n;len++){//枚举长度
        for(int j = 1;j+len<=n+1;j++){//枚举起点，ends<=n
            int ends = j+len - 1;
            for(int i = j;i<ends;i++){//枚举分割点，更新小区间最优解
                dp[j][ends] = min(dp[j][ends],dp[j][i]+dp[i+1][ends]+something);
            }
        }
}
```



#### 数位DP



### 树形DP🌟

[博客](https://blog.csdn.net/m0_59459037/article/details/119189656)

从根节点出发，向子节点做深度优先搜索，并由其子节点的最优解合并得到该节点的最优解。

#### 树上动态规划



#### 树上01背包



#### 树上多重背包













## 图论

### 强连通分量

[博客](https://blog.csdn.net/qq_25930891/article/details/123208901)

#### 定义

在一个图G中，若两个点互相可到达，则称该两点**强连通**，若该图中每两个点之间都是强连通，则该图为一个**强连通图**。

有向非强连通图的极大强连通子图，称为**强连通分量** 。

#### 作用

降低图的规模，从而减小图的复杂度。

#### Tarjan算法

可以找出一个图中所有的强连通分量。

不断dfs搜索，遇到环则进行更新，然后返回。

```cpp
void tarjan(int x) {
    s.push(x);
    instack[x] = 1;	
    
    dfn[x] = low[x] = ++cnt; //初始化dfn和low
    
    //核心代码，深搜这个点
    for (int i = head[x]; i; i = edge[i].next) {
        int to = edge[i].to;
        if(!dfn[to]){	//如果下一个点没有被搜过，
            tarjan(to);	//继续深搜
            low[x] = min(low[x], low[to]); //更新low
        }
        else if(instack[to]){ //如果下一个点已经被搜过，看他在不在栈里
            low[x] = min(low[x], dfn[to]); //更新low
        }
    }
    //如果dfn==low，即找完了一整块强连通分量，出栈+标记
    if(dfn[x] == low[x]){
        tot++;//计数器++，第几个强连通分量
        while(s.top()!=x){ 		//不加1的话x这个点不会被出栈
            scc[s.top()] = tot;	//打标记
            s.pop();//出栈
            instack[x]=0;
        }
    }
}

```



#### 缩点

[博客](https://blog.csdn.net/ez_gsn/article/details/122898581?spm=1001.2101.3001.6650.7&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-7-122898581-blog-93732524.pc_relevant_multi_platform_featuressortv2dupreplace&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-7-122898581-blog-93732524.pc_relevant_multi_platform_featuressortv2dupreplace&utm_relevant_index=8)

就是把原本的环缩到一个点上，这样的话图中所有的环都消失了

```cpp
void search (int u)
{
	if (f[u]) return;
	f[u] = sum[u];
	int maxsum = 0;
	for (int i = hd[u]; i; i = e[i].nxt)
	{
		int v = e[i].to;
		if (!f[v]) search (v);
		maxsum = max (maxsum, f[v]);
	}
	f[u] += maxsum;
}

```



#### 割点

⚠️ 仅针对无向图

**连通** ：图中任意两个点之间可互相到达

**割点**：在一个**无向图**里，去掉一个顶点，及其去掉该点的所有边,剩下的图不连通，那么这个点就是个**割点**。

**割边**：在一个**无向图**里，去掉一条边，图就不连通了。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define _ 200010
using namespace std;
	struct node{int x,y,next;} a[_];
	int n,m,len=0,id=0,ans=0;
	int last[_],low[_],dfn[_];
/*dfn[i]表示点i被访问的时间戳 
low[i]表示点i及i的子树中所有结点能到达的结点中dfn最小的结点的时间戳*/ 
	bool bz[_];
void ins(int x,int y)
{
	a[++len].x=x;a[len].y=y;a[len].next=last[x];last[x]=len;
}
void dfs(int x,int root)
//x表示当前访问到第x个点,root表示已root为根节点的子树的根 
{
	int tot=0;
	low[x]=dfn[x]=++id;
//记录时间戳 
	for(int i=last[x];i;i=a[i].next)
	{
		int y=a[i].y;
		if(!dfn[y])
		{
			dfs(y,root);
			low[x]=min(low[x],low[y]);
//更新当前节点的low值 
			if(low[y]>=dfn[x]&&x!=root) bz[x]=true;
/*非根且子树能达到的dfn最小的结点的时间>=自己的时间时,
说明它的子树中最早能访问到的结点都比它后访问,此时只要不为根就一定是割点*/ 
			if(x==root) tot++;
//更新入度 
		}
		low[x]=min(low[x],dfn[y]);
//把点x及x的子树可以达到的dfn的最小结点更新
	}
	if(x==root&&tot>=2) bz[root]=true;
//如果一个点为根且入度>=2,则一定为割点,因为一棵树的根一删不那么它的子树一定不连通了
}
int main()
{
	int x,y,t;
	scanf("%d %d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%d %d",&x,&y);
		ins(x,y);
		ins(y,x);
	}
	for(int i=1;i<=n;i++)
		if(!dfn[i]) dfs(i,i);
	for(int i=1;i<=n;i++)
		if(bz[i]) ans++;
	printf("%d\n",ans);
	for(int i=1;i<=n;i++)
		if(bz[i]) printf("%d ",i);
}

```









### 最小生成树

**定义** ：对带权**联通**无向图G，生成一棵权值最小的树。

**性质**：

+ 可能含有多个最小生成树，但是最小权值之和唯一。
+ 边数=点数 - 1



#### Prim

**思想** ：从一个顶点开始构建，每次将花费最小的新顶点加入，直到所有顶点都加入。

**时间复杂度** ：$O(\mid V \mid ^2)$   ，适用于稠密图

```cpp
//Prim
int maxn;  //最大结点数
int INF = 1000000000;
int dis[maxn]; //顶点与集合中任一点的最短距离
bool vus[maxn]; //是否已加入
int Prim()
{
    fill(dis,dis+maxn,INF);   //初始化dis数组为INF
    dis[0]=0;   //选择0号结点加入，则只有0号节点距离为0
    int ans = 0;  //由于一开始只有一个结点，没有边，所以边权之和为0
    for(int i=0;i<n;i++)
    {
        int u = -1;
        int minn = INF;
        for(int j=0;j<n;j++)
        {
            if(!vis[j] && dis[j]<minn)  //没被访问过且距离最短
            {
                u = j;
                minn = dis[j];
            }
        }
        if(u==-1) //没有找到
        	reutnr -1;
       	
        vis[u]=1;
        ans+=dis[u];
        for(int v = 0; v<n; v++)
        {
            if(!vis[v] && a[u][v]!=INF && a[u][v]<dis[v])
            {
                dis[v]=a[u][v];
            }
        }
    }
    
    
}
```




#### Kruskal

**思想** ：每次选择权值最小的边加入，且两个端点没有联通，直到所有结点都联通

**时间复杂度** ：$O(\textbar E \textbar log_2\textbar E \textbar)$

```cpp
//Kruskal

struct Edge{
    int u;
    int v;
    int w;
}e[maxm];
bool cmp(Edge p,Edge q)
{
    return p.w<q.w;
}

int find(int x)
{
    
    if(fa[x]!=x)
    {
        fa[x]=find(fa[x]);
    }
    return fa[x];
}

void Kruskal()
{
    sort(e+1,e+m+1,cmp);
    for(int i=1;i<=m;i++)
    {
        int faa = find(e[i].u);
        int fab = find(e[i].v);
        if(faa = fab)
            continue;
        fa[fab]=faa;
        ans+=e[i].w;
        if(++cnt == n-1)
            break;
    }
}
```



### 单源最短路径

![vro8Og.png](https://s1.ax1x.com/2022/08/19/vro8Og.png)

#### Floyd

**思想** ：枚举

时间复杂度：$O(n^3)$   ，    空间复杂度： $O(n^2)$

**适用条件** ： 不能有负环，且必须存在最短路

```c++
for(int k = 1; k <= n; k++){
    for(int x = 1; x <= n; x++){
        for(int y = 1; y <= n; y++){
            f[x][y]= min(f[x][y], f[x][k]+f[k][y]);
        }
    }
}
```



#### SPFA

[博客](https://blog.csdn.net/qq_39670434/article/details/78464995)

##### 最短路

**思路**：由一个点不断扩展子节点，如果能够进行迭代，那么入队，被入队的点再进行扩展....

```cpp
void SPFA()
{
    for(int i=1;i<=n;i++)
    {
        dis[i]=maxint;
        vis[i]=false;
    }
    dis[s]=0;
    vis[s]=true;
    int u;
    q.push(s);
    while(!q.empty())
    {
        u=q.front();
        for(int i=head[u];i;i=e[i].nxt)
        	if(dis[u]+e[i].len<dis[e[i].to])
        	{
            	dis[e[i].to]=dis[u]+e[i].len;
            	if(vis[e[i].to]==false)
            	{
                	vis[e[i].to]=true;
                	q.push(e[i].to);
            	}
        	}
        vis[q.front()]=false;
      	q.pop();
    }
}
```



##### 负环

每次入队的时候记录一下

```cpp
bool SPFA() {
    dis[1] = 0;
    vis[1] = true;
    q.push(1);
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        vis[u] = false;
        for (int i = head[u]; i; i = e[i].nex) {
            int to = e[i].to;
            if (e[i].val + dis[u] < dis[to]) {
                dis[to] = dis[u] + e[i].val;
                cnt[to] = cnt[u] + 1;
                if (cnt[to] >= n) return true;
                if (!vis[to]) {
                    q.push(to);
                    vis[to] = true;
                }
            }
        }
    }
    return false;
}
```



##### 差分约束

[博客](https://blog.csdn.net/qq_49688477/article/details/125613544?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-125613544-blog-72849441.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-125613544-blog-72849441.pc_relevant_default&utm_relevant_index=1)

```cpp
asd
```







#### Dijkstra

**思想** ：类似于 Prim ，不断找到耗费最小的点，进行标记，直到达到目标

时间复杂度： $O(n^2)$    ，  空间复杂度： $O(m log m)$

```c++
const int inf=0x3f3f3f3f; //代表无穷大。
const int maxn=100;//最大顶点数
int n,m;//n个顶点，m条边。
bool visited[maxn];//判断是否确定到源点的最终最短距离。
int graph[maxn][maxn];//带权图
int dis[maxn];//顶点到源点的最短距离。
int start,goal;//起点与目标点。


void init(){
	memset(visited,false,sizeof(visited));
	for(int i=1;i<=n;i++){
		dis[i]=graph[start][i];//初始化dis数组。
	}
}


void dijkstra(){
	//源点为源点start。
	int minn;//记录每趟最短路径中最小的路径值。 
	int pos;//记录得到的minn所对应的下标。
	init();//调用初始化函数。
	visited[start]=true;
	for(int i=1;i<=n;i++){
		//将n个顶点依次加入判断。
		minn=inf;
		for(int j=1;j<=n;j++){
			if(!visited[j]&&dis[j]<minn){
				minn=dis[j];
				pos=j;
			}
		}
		//经过这趟for循环后我们找到的就是我们想要的点，可以确定这点到源点的最终最短距离了。
		visited[pos]=true;//我们将此点并入已知集合。
		//接下来就是更新dis数组了，也就是当前最短距离，这都是针对还没有并入已知集合的点。
		for(int j=1;j<=n;j++){
			if(!visited[j]&&dis[j]>dis[pos]+graph[pos][j])
				dis[j]=dis[pos]+graph[pos][j];
		}
	}
	//退出循环后，所有的点都已并入已知集合中，得到的dis数组也就是最终最短距离了。
	cout<<dis[goal]<<endl;//输出目标点到源点的最短路径长度。
}

```



##### 优先队列优化版

**思想** ：利用最小堆维护最小值，不用再去循环枚举找出最小值。

**时间复杂度**：$MlogM$

```cpp
typedef pair<int,int> pdd;

int head[maxn], dis[maxn];
bool vis[maxn];

struct Edge{
    itn u,v,w;
    int nex;
}e[maxm];

inline void add(int a,int b,int c)
{
    e[++cnt].u=a;
    e[cnt].v=b;
    e[cnt].w=c;
    e[cnt].nex=head[a];
    head[a]=cnt;
}

priority_queue<pdd,vector<pdd>,greater<pdd>> q;

void dijkstra()
{
    while(!empty())
    {
        pdd t = q.top();
        q.pop();
        int now = t.second;
        if(vis[now])
            continue;
        vie[now]=true;
        
        for(int i = head[now]; i; i = e[i].nex)
        {
            int to = e[i].v;
            if(dis[to]>dis[now]+e[i].w)
            {
                dis[to]= dis[now] + e[i].w;
                q.push({dis[to],to});
            }
        }
    }
    
}
```





### 最近公共祖先（LCA）

博客[链接](https://blog.csdn.net/qq_43332980/article/details/107437070?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-107437070-blog-121195470.pc_relevant_multi_platform_featuressortv2removedup&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-107437070-blog-121195470.pc_relevant_multi_platform_featuressortv2removedup)

#### 倍增（在线）

##### 复杂度

预处理：`O(nlogn)`

单次查询：`O(logn)`

总复杂度：`O(nlogn+mlogn)`

##### 实现

采用`f[x][i]`数组来表示点 x 的第 $2^i$ 个祖先

```cpp
//预处理f数组
for(int i=1;(i<<i)<d[u];i++)
{
  	f[u][i] = f[f[u][i-1]][i-1];
}
```

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAX_N = 500000+7, MAX_M = 500000+7;

int n,m,s;
int d[MAX_N]; //保存节点深度
int f[MAX_N][21]; //保存节点的不同倍数的父节点

int head[MAX_N], cnt=-1;
struct Edge{
    int to , next;
}e[MAX_N*2];

void add(int u,int v){
    e[++cnt].to = v;
    e[cnt].next = head[u];
    head[u] = cnt;
}

void dfs(int u,int fa) // u为当前节点,fa为父节点
{
    f[u][0] = fa;
    d[u] = d[fa]+1;

    for(int i=1;(1<<i)<=d[u];i++)
        f[u][i] = f[f[u][i-1]][i-1];    //预处理f数组

    for(int i=head[u];i!=-1;i=e[i].next){
        int v = e[i].to;
        if(v!=fa)
            dfs(v,u);
    }
}

int lca(int x,int y)
{
    if(d[x]>d[y])  //令y为更深节点
    	swap(x,y);
    
    for(int i=20;i>=0;i--){   //这里使得x与y处于同一深度
        if(d[x]<=d[y]-(1<<i))
            y=f[y][i];
    }

    //特判
    if(x==y)
        return x;
    
    for(int i=20;i>=0;i--)
    {
        if(f[x][i]==f[y][i])
            continue;              //这里是从最远的公共祖先开始找，所以需要continue
        else
            x=f[x][i],y=f[y][i];   //上跳
    }

    return f[x][0];
}

int main()
{
    memset(head,-1,sizeof(head));
    int a,b;
    scanf("%d%d%d",&n,&m,&s);
    for(int i=1;i<n;i++)
    {
        scanf("%d%d",&a,&b);
        add(a,b);
        add(b,a);                      //无向图，要加两次
    }
    dfs(s,0);

    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&a,&b);
        printf("%d\n",lca(a,b));
    }

    return 0;
}

```



#### ST+RMQ(在线)

##### 复杂度

预处理：`O(logn)`

查询：`O(1)`

总复杂度：`O(nlogn+m)`

##### 原理

将一棵树转为dfs序后，也就是说dfs序的一段区间是原树的一棵子树。

而要查找两个点的最近公共祖先，只要找dfs序中两个点之间深度最小的那个点即可。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAX_N = 500000+7, MAX_M = 500000+7;

int n,m,s;

//dfs序数组
int tot = 0;
int fir[MAX_N];
int dfn[MAX_N*2];
int d[MAX_N*2];

//ST表数组
int st[20][MAX_N*2];   //st表
int ist[20][MAX_N*2];  //记录最值下标
int Log[MAX_N*2];

void getLog()
{
	Log[1] = 0;
	for(int i=2;i<=MAX_N*2;i++)
		Log[i] = Log[i/2]+1;
}

void init()
{
    for(int i=1;i<=tot;i++){
        st[0][i]=d[i];
        ist[0][i] = dfn[i];
    }
    for(int j=1;(1<<j)<=tot;j++){
		for(int i=1;i+(1<<(j-1))<=tot;i++){
            if(st[j-1][i]<st[j-1][i+(1<<(j-1))]){
                st[j][i] = st[j-1][i];
                ist[j][i] = ist[j-1][i];
            }else{
                st[j][i] = st[j-1][i+(1<<(j-1))];
                ist[j][i] = ist[j-1][i+(1<<(j-1))];
            }
        }
    }

    getLog();
}

int Query(int l,int r)
{
	int k=Log[r-l+1];
	int ans;

    if(st[k][l]<st[k][r-(1<<k)+1]) 
        ans = ist[k][l];
    else 
        ans = ist[k][r-(1<<k)+1];

    return ans;
}


int head[MAX_N], cnt=-1;
struct Edge{
    int to , next;
}e[MAX_N*2];

void add(int u,int v){
    e[++cnt].to = v;
    e[cnt].next = head[u];
    head[u] = cnt;
}

void dfs(int u,int dep) // u为当前节点,dep为深度
{
    fir[u] = ++tot;
    dfn[tot] = u;
    d[tot] = dep;

    for(int i=head[u];i!=-1;i=e[i].next){
        int v = e[i].to;
        if(!fir[v]){
            dfs(v,dep+1);
            dfn[++tot]=u;
            d[tot]=dep;
        }
    }
}


int lca(int x,int y)
{
    int l = fir[x] , r = fir[y];
    if(l>r) swap(l,r);
    return Query(l,r);
}


int main()
{
    memset(head,-1,sizeof(head));
    int a,b;
    scanf("%d%d%d",&n,&m,&s);
    for(int i=1;i<n;i++)
    {
        scanf("%d%d",&a,&b);
        add(a,b);
        add(b,a);                      //无向图，要加两次
    }
    dfs(s,0);
    init();

    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&a,&b);
        printf("%d\n",lca(a,b));
    }

    return 0;
}

```

#### Tarjan（离线） 存在问题，洛谷模板过不了

##### 思路

+ 任选一个点u为根节点，开始遍历
+ 遍历所有的子节点v，并进行标记
+ 若有子节点v还有子节点，那么重复第二步，继续遍历
+ 合并v到u上（使用并查集）
+ 寻找与u有关系的查询节点v
+ 若v已被访问过，则可以直接求出LCA，即为v被合并到的父亲结点

**伪代码**：

```cpp
Tarjan(u)//marge和find为并查集合并函数和查找函数
{
    for each(u,v)    //访问所有u子节点v
    {
        Tarjan(v);        //继续往下遍历
        marge(u,v);    //合并v到u上
        标记v被访问过;
    }
    for each(u,e)    //访问所有和u有询问关系的e
    {
        如果e被访问过;
        u,e的最近公共祖先为find(e);
    }
}
```

```cpp
void Tarjan(int u,int fa) // u为当前节点,fa为父节点
{

    for(int i=head[u];i!=0;i=e[i].next){
        int v = e[i].to;
        if(v!=fa&&!vis[v]){
            Tarjan(v,u);
            unionn(u,v);   // 注意这里位置不能交换， 原树上u为v的父节点
            vis[v]=true;   // 标记访问
        }
    }

    for(int i=que[u];i!=0;i=q[i].next){
        int v = q[i].to;
        if(!q[i].flag&&vis[v]){
            ans[q[i].num] = find(v);
            q[i].flag = true;           //完成询问则把镜像问题也打上标记
            q[q[i].same].flag = true;
        }
    }
}
```



### 树链剖分

#### 使用场景

+ 从子节点到根结点到路程中 操作
+ 从根节点到其所有子节点 操作

概念：**重儿子** --- 一个节点中子树最大的儿子。

**寻找重儿子**

```cpp
void dfs_getson(int x)
{
  	size[x] = 1;
  	for(int i = head[x];i; i = e[i].nex)
    {
      int v = e[i].to;
      if(v == fa[x]) continue; //不能往回走
      fa[v] = x; 
      deep[v] = deep[x] + 1; //记录父亲和深度
      dfs_getson(v);
      size[x]+=size[v];
      if(size[v]>size[son[x]]) 
        son[x]=v; //更新重儿子
    }
}
```

**将寻找到的重儿子连接起来，成为重边**

```cpp
void dfs_rewrite(int x,int tp)//当前点以及当前点所在重链的顶端
{
    top[x]=tp;  //更新每个点所在的重链的顶端 
    id[x]=++cnt;//得到每个点的dfs序（新编号） 
    rk[tot]=x;  //记录每个新编号对应的原来的点 
    if(son[x])
      dfs_rewrite(son[x],tp);//优先往重儿子那里走 
    for(int i=head[x];i;i=e[i].next)
    {
        int v=e[i].to;
        if(v!=son[x] && v!=fa[x])
          dfs_rewrite(v,v);
    }
    ctr[x]=tot; //作用后面会讲 
}
```











## 数论

### 容斥原理

[博客](https://blog.csdn.net/AGNING/article/details/105371507?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166062540216780357250140%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166062540216780357250140&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-105371507-null-null.142^v40^pc_rank_34_2,185^v2^control&utm_term=容斥原理&spm=1018.2226.3001.4187)

#### 概念

[![vsYttx.png](https://s1.ax1x.com/2022/08/20/vsYttx.png)](https://imgse.com/i/vsYttx)

要把1-n中2、3、5的倍数全部筛掉，那么先筛2的倍数，再筛3的倍数，再筛5的倍数，这样的话6、10、15的倍数就被筛了两遍，30的倍数就被筛了三遍。因此，只要减去6、10、15的倍数，但是这样一减，30的倍数又被减了3遍，也就是说，30的倍数没有被加过，所以再加上就可以了。

容斥原理可以用来求1-n中的所有质数。

#### 实现

先分解质因子：

```cpp
 for (int i = 2; i * i <= k; i++) {
        if (k % i == 0) {
            p[++tail] = i;  //p就是储存质因子的数组
            while (k % i == 0) k /= i;  //把k中所有i的质因子全部除去
        }
    }
    if (k > 1) p[++tail] = k;  //最后如果大于一，则最后一个数一定是质因子，这一步可能有一点难理解，可以多想想
```

再实现容斥：

```cpp
long long fun(long long x){
    long long res=0;  //记录1-x中与k不互质的数量
    for(int i=1;i<(1<<tail);i++){  //这里的1<<tail是指2的tail次方，表示tail个质因子有多少种组合情况 
        long long cur=1,cnt=0;  //cur表示在当前选中的质因子中的乘积，cnt表示当前选中的数量是奇数还是偶数 
        for(int j=0;j<tail;j++){  //这个循环是枚举tail的二进制形式 
            if((i>>j)&1){  //这个是判断i的第j位是不是1，如果是则表示选中第j个数 
                cnt++;  //表示选中了几个数，每选中一个就加一 
                cur*=p[j+1];  //选中第j个数就用cur乘以第j个质因子数，注意质因子数组是从1开始的，所以要加一 
            }
        }
        if(cnt&1) res+=x/cur;  //如果cnt是偶数就相加 
        else res-=x/cur;  //奇数就相减 
    }
    return x-res;  //res储存的是1-x中与K不互质的数量，所以要用x-res得到互质的数量 
}


```





### 康托展开

**定义** ：给定自然数排列，求出由小到大中所有排列的该排列序号

![](https://i.bmp.ovh/imgs/2022/08/19/8b20cd5cf04fcce4.png)

以下是O(n^2)做法，可用树状数组存tmp，将时间复杂度降低到O(nlogn)


```cpp
void jiecheng(int x)
{
    f[0]= f[1] =1;
    for(int i = 2; i <= n; i++) f[i] = f[i - 1] * i;
}
int kangtuo()
{
    int ans =1;
    int len = str.length();
    
    for(int i=0;i<len;i++)
    {
        int tmp =0;
        for(int j=i+1;j<len;j++)
        {
            if(str[i]>str[j]) tmp++;
        }
        ans+=tmp*f[len-i+1];
    }
    return ans;
}
```



#### 逆展开

**定义** ：给定一个序号，求出对应的自然数排列

```cpp
void jie_cheng(int n)
{
    f[0] = f[1] = 1; // 0的阶乘为1
    for(int i = 2; i <= n; i++) f[i] = f[i - 1] * i;
}

vector<char> vec; //存需要排列的字符
void rev_kangtuo(int k) //输出序号为 k 的字符序列
{
    int n = vec.size(), len = 0;
    string ans = "";
    k--; // 算的时候是按 12345 是第0位
    for(int i = 1; i <= n; i++){
        int t = k / f[n - i]; // 第 i 位需要 第 t + 1 大的数
        k %= f[n - i];        //剩下的几位需要提供的排列数
        ans += vec[t] ; //  vec[t] 就是第 t + 1 大的数
        vec.erase(vec.begin() + t); 
//用过就删了，不用vector用暴力也可以，就是说枚举，然后一个一个的比较大小，并记录有几个没用过的字符且字典序比它小
    }
    cout << ans << '\n';
}
```



### 乘法逆元

#### 定义

​	若**a**与**p**互质 a * b = 1 (mod p) --> a与b的乘积在模p时恒等于1，则b是a在模p情况下的逆元

​	可以根据乘法逆元，将 (a / b) % c 转化为 (a * x) % c ，将除法转化为乘法。

#### 解法

##### 费马小定理

​	假如p是质数，且$gcd(a,p)=1$，那么 $a^ {p-1}≡1(mod p)$ 。

​	根据费马小定理，a 的逆元即为 $a^{p-2}$

```cpp
需要结合快速幂
ll fpm(ll x, ll power, ll mod) {
    x %= mod;
    ll ans = 1;
    for (; power; power >>= 1, (x *= x) %= mod)
    	if(power & 1) (ans *= x) %= mod;
    return ans;
}
int main() {
	ll x = fpm(a, p - 2, p); //x为a在mod p意义下的逆元
}
```



##### 扩展欧几里得定理

​	必存在 x y ，满足等式 a*x + b*y = gcd(a,b)  因此，若gcd(a,b)=1，则可以求乘法逆元

可递归得出结论：` x = y' ,y = x'- a/b * y'`

```cpp
void exgcd(ll a, ll b, ll &x, ll &y)
{
    if (!b) //递归到特解开始回溯
    {
        x = 1;
        y = 0;
        return;
    }
    exgcd(b, a % b, x, y); //求得x2,y2
    ll temp = x;
    x = y;                  //回溯，利用x2递推x1
    y = temp - (a / b) * y; //回溯，利用y2递推y1
}
int main()
{
    ll a, b, x, y;
    cin >> a >> b;
    exgcd(a, b, x, y);
    cout << x << ' ' << y << endl;
    return 0;
}
```

##### 递推公式

从一到n的逆元：

这个式子必须从1开始递推

![image.png](https://s2.loli.net/2022/08/20/MLnIpJgbjHkRP7Y.png)



### 欧拉定理

**定义** ：对任意两个正整数a,n，若两者互质，则$a^{φ(n)}≡1(mod n)$

​	可用于降幂操作。

#### 前置知识

**欧拉函数**：对正整数n，欧拉函数 $φ(n)$ 是小于n的正整数中与n互质的数的数目。

```cpp
typedef long long ll;
ll Eular(ll n)
{
    ll ans=n;
    for(int i=2; i*i <= n; ++i)
    {
        if(n%i == 0)
        {
            ans = ans/i*(i-1);
            while(n%i == 0)
                n/=i;
        }
    }
    if(n > 1) ans = ans/n*(n-1);
    return ans;
}
```

若n为质数，则 $φ(n) = n-1$ 

#### 扩展欧拉定理

![](https://i.bmp.ovh/imgs/2022/08/19/dee20be7eed215b7.png)

##### 应用范围

扩展欧拉定理适用于模数较小，指数较大的情况下，进行降幂操作。

+ 配合大数取余求解

e.g. 给定 a,m,b， 求 $a^b mod\ m$ 



### 扩展欧几里得定理

#### 应用

##### 二元一次不定方程







### 高斯消元法









### Lucas

[博客](https://blog.csdn.net/qq_40679299/article/details/80489761)

