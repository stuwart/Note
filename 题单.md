## 题单

+ [基础算法](https://www.luogu.com.cn/training/2929)
+ [拓展模板](https://www.luogu.com.cn/training/2650)  难度较大
+ [提高数据结构](https://www.luogu.com.cn/training/2649)
+ [进阶数据结构](https://www.luogu.com.cn/training/3367#information)
+ [DP基础](https://www.luogu.com.cn/training/5011)
+ [动态规划提高](https://www.luogu.com.cn/training/12927)
+ [动态规划综合](https://www.luogu.com.cn/training/1435#information)
+ [数论](https://www.luogu.com.cn/training/3135#information)
+ [图论模板](https://www.luogu.com.cn/training/3364)
+ [提高图论](https://www.luogu.com.cn/training/4969)
+ [思维题](https://www.luogu.com.cn/training/4865#problems)
+ [综合](https://www.luogu.com.cn/training/9391)



## BASE

### 快速幂

最快的快速幂算法，运用了位运算大大加快运算速度。

```cpp
long long fastPower(long long base, long long power) {
    long long result = 1;
    while (power > 0) {
        if (power & 1) {//此处等价于if(power%2==1)
            result = result * base ;
        }
        power >>= 1;//此处等价于power=power/2
        base = (base * base) ;
    }
    return result;
}
```



### 矩阵快速幂

**先修知识：线性代数  （狗头）**

时间复杂度：$O(log_2k)$ 

```cpp
struct matrix
{
    int n,m;   
    int e[105][105];
}
matrix a,b;

matrix mul(matrix a,matrix b)
{
    matrix ans;
    ans.n=a.n;
    ans.m=b.m;
    
    for(int i=1;i<=ans.m;i++)
   		for(int j=1;j<=ans.m;j++)
            ans.e[i][j]=0;     //初始化
    
    for(int i=1;i<=a.n;i++)
        for(int j=1;j<=b.m;j++)
            for(int k=1;k<=a.m;k++)
                ans.e[i][j]=(ans.e[i][j]+(a.e[i][k]*b.e[k][j])%mod)%mod;//快速幂的取模就在这里了！
    return ans;
}

matrix power(matrix a,ll b)
{
    matrix ans;
    ans.n=a.n;
    ans.m=a.m;
    //初始化为单元矩阵
    for(int i=1;i<=ans.n;i++)
    	for(int j=1;j<=ans.m;j++)
            if(i==j) 
                ans.e[i][j]=1;
    		else 
                ans.e[i][j]=0;    
    
    while(b)
    {
        if(b&1)
            ans=mul(ans,a);
       	a=mul(a,a);
        b>>=1;
    }
    return ans;
}
```



### bitset

[博客](https://www.cnblogs.com/zwfymqz/p/8696631.html)



### ST算法

**RMQ**：区间最大值/最小值查询

**复杂度**

预处理：`O(nlogn)`

查询：`O(1)`



**实现**

预处理，算出每个区间之间的最值。

`s[i][j]` 代表从i开始第$2^j$ 个数。

```cpp
void init(int x)
{
  	for(int i=1;i<=n;i++)
        st[i][0]=a[i];
  	
  	for(int j=1;(1<<j)=sizeof(a);j++)
    {
      	for(int i=1;i+(1<<(j-1))<=sizeof(a);i++)
        {
          	st[i][j] = max(st[i][j-1],st[i+(1<<(j-1))][j-1]);
        }
    }
}
```



**查询**

```cpp
int Log[n+7];
void getLog()
{
	Log[1] = 0;
	for(int i=2;i<=n+1;i++)
		Log[i] = Log[i/2]+1;
}

int query(int l,int r)
{
   int k = Log(r-l+1);
   ans = max(st[l][k],st[r-(1<<k)+1][k];
   return ans;
}
```



## 字符串算法

### KMP

用于判断一个字符串中是否存在另一个字符串，输出位置。

+ 用一个`nex`数组维护 最长的 前缀与后缀相同的子串（最大为 n-1 ）
+ 从前往后遍历，如果符合字符串a与字符串b的这个位置的字母相同，那么+1,否则回退到`nex[j]`

[![vL7nn1.png](https://s1.ax1x.com/2022/09/10/vL7nn1.png)](https://imgse.com/i/vL7nn1)

```cpp
cin >> a + 1;
cin >> b + 1;
la = strlen(a + 1);
lb = strlen(b + 1);
for (int i = 2; i <= lb; i++) //求nex数组
{
    while (j && b[i] != b[j + 1])
        j = kmp[j];
    if (b[j + 1] == b[i])
        j++;
    kmp[i] = j;
}
j = 0;
for (int i = 1; i <= la; i++)
{
    while (j > 0 && b[j + 1] != a[i])
        j = kmp[j];
    if (b[j + 1] == a[i])
        j++;
    if (j == lb)
    {
        cout << i - lb + 1 << endl;
        j = kmp[j];
    }
}

for (int i = 1; i <= lb; i++)
    cout << kmp[i] << " ";
```



### Manacher

时间复杂度：`O(n)`，求解一个字符串的最长回文子串长度。

[![vOSklV.png](https://s1.ax1x.com/2022/09/10/vOSklV.png)](https://imgse.com/i/vOSklV)

[![vOSAyT.png](https://s1.ax1x.com/2022/09/10/vOSAyT.png)](https://imgse.com/i/vOSAyT)

```cpp
void manacher()
{
    int r = 0, mid = 0;
    int size = strlen(a + 1);
    s[++cnt] = '~';
    s[++cnt] = '#';
    for (int i = 1; i <= size; i++)
    {
        s[++cnt] = a[i];
        s[++cnt] = '#';
    }
    s[++cnt] = '!';

    for (int i = 2; i <= cnt - 1; i++)
    {
        p[i] = r > i ? min(r - i, p[2 * mid - i]) : 1;
        while (s[i + p[i]] == s[i - p[i]])
        {
            p[i]++;
        }
        if (i + p[i] > r)
        {
            r = i + p[i];
            mid = i;
        }
        ans = max(ans, p[i] - 1);
    }
}
```



### AC自动机



### 回文自动机（PAM）



### 后缀数组



### 后缀自动机（SAM）







## 数据结构

### 链表

**存储线性表的数据元素，可以是不连续的**

##### 动态链表

```c++
#初始化
struct node{
    int data;
    node *next;
};

node *head, *p, *now, *prev;

head = new node;          //定义变量
head->data = 1;          //分配第一个节点，数据置为1
head->next = NULL;  //
now = head;  //当前指针为头指针
```



##### 结构体实现链表

```c++
(单向)
struct node{
    int id;
    int nextid;
}nodes[maxn];

nodes[0].nextid = 1;
for(int i=1;i<=n;i++)
{
    nodes[i].id=i;
    nodes[i].nextid = i+1;
}
nodes[n].nextid = 1;  //循环链表

```



##### STL list

list为双向链表。

```c++
//初始化
list<int> l1;  //空对象
list<int> l2(3,1); //包含3个1的对象

//遍历

list<int>::iterator it = l2.begin();
while(it != l2.end())
{
    *it += 1;
    cout<<*it<<' ';
    it++;
}

//范围for遍历
for(auto& e:l2)
{
    cout<<e<<' ';
}

//插入
l1.push_back(xx);
l1.push_front(xx);
l1.pop_front();
l1.pop_back();

insert:
auto pos = ++l1.begin();
l1.insert(pos,5); //在pos位置前加一个5
l1.insert(pos,3,5); //在pos位置前加3个5

erase:
l1.erase(pos);   //删除pos位置元素
l1.erase(++le.begin(),--l1.end());  //删除中间内容


//清空：
l1.clear();

```



### 并查集

**一种树形数据结构，用于处理不交集的合并及查询问题**

#### 创建

```c
void init(int size){
    for(int i=0;i<size;i++)
    {
        fa[i]=i;
    }
}
```



#### 查找

```c
int find(int x){
    if(fa[x]==x)
        return x;
    else
        return find(fa[x]);
}

//路径压缩版本

int find(int x){
    if(fa[x]!=x)
        fa[x]=find(fa[x]);
    return fa[x];
}
```



#### 合并

```c
viod merge(int x,int y){
    x=find(x);
    y=find(y);
    fa[x]=y;
}
```



#### 启发式合并（按秩合并）

运用于： 可持久化并查集、线段树分治 + 并查集

```c
//选择点数作为估价函数

vector<int> size(N,1);  //记录并初始化子树的大小为1

void merge(int x,int y){
    int xx = find(x);
    int yy = find(y);
    if(xx == yy) return;
    if(siez[xx] > size[yy])  // 保证小的合并到大的
        swap(xx,yy);
    fa[xx]=yy;
    size[yy]+=size[xx];
}
```





### 树状数组

#### 场景

单点修改，区间查询。



#### 复杂度

时间复杂度： 查询与修改均为 $log(n)$



**根本**：

```cpp
int lowbit(int x)   //作用：找到最后一位
{
    return x&(-x);
}
```



**求前缀和** 

```cpp
int getSum(int m){
	int ans = 0;
    while(m > 0){
        ans += C[m];
        m -= lowbit(m);
    }
    return ans;
}
```



**更新**

```cpp
void update(int x, int value){
    A[x] += value;	// 修改源数组
    while(x <= n){
        C[x] += value;
        x += lowbit(x);
    }
}

```



**示意图**：

![image.png](https://s2.loli.net/2022/07/22/9QK5rJvCuyUDms7.png)













### 线段树

#### 场景

+ 单点修改、区间修改
+ 查询区间的值



#### 操作

##### 建树

```cpp
void build(int k,int l,int r)
{
    if(l==r)
        t[k] = a[i];
   	else
    {
        int m = (r-l)<<1+l;
        build(k<<1,l,m);
        build(k<<|1,m+1,r);
    }
}
```

##### 点更新

```cpp
void update(int p,int v,int k,int l,int r) //点更新
{
    if(l==r)
    {
        a[k] += v;
        t[k] += v;
    }
    else{
        int m = (r - l) / 2 + l;
        if (p <= m)
        {
            update(p, v, k << 1, l, m);
        }
        else{
            update(p, v, k << 1 | 1, m + 1, r);
        }
        Pushup(k);
    }
}
```

##### 区间更新

```cpp
void Update(int L,int R,int v,int k,int l,int r) //区间更新
{
    if(L<=l && R>=r)
    {
        t[k]+=v;
        lazy[k] += v;
    }
    else
    {
        Pushdown(k);
        int m = (r - l) / 2 + l;
        if(L<=m)
        {
            Update(L, R, v, k >> 1, l, m);
        }
        if(R>m)
        {
            Update(L, R, v, k >> 1 | 1, m + 1, r);
        }
        Pushup(k);
    }
}
```

##### 区间求最值

```cpp

ll ask(int L,int R,int k,int l,int r)   //区间查询最值
{
    if(L<=l && R>=r)
        return t[k];
    else
    {
        Pushdown(k);
        ll ans = INF;
        int m = (r - l) / 2 + l;
        if(L<=m)
            ans = max(ans, ask(L, R, k << 1, l, m));
        if(R>=m+1)
            ans = max(ans, ask(L, R, k >> 1 | 1, m + 1, r));

        return ans;
    }
}

```



##### 上升

```cpp
void pushup(int k)
{
    t[k] = t[k << 1] + t[k << 1 | 1];
}
```

##### 下降

```cpp
void pushdown(int k, int l, int r)
{
    int m = (l + r) >> 1;
    if (lazy[k] != 0)
    {
        lazy[k << 1] +=lazy[k];
        lazy[k << 1 | 1] += lazy[k];
        t[k << 1] += lazy[k] * (m - l + 1);
        t[k << 1 | 1] += lazy[k] * (r - m);
        lazy[k] = 0;
    }
}
```

### Tire树

[![vO1KS0.png](https://s1.ax1x.com/2022/09/10/vO1KS0.png)](https://imgse.com/i/vO1KS0)

如图，涂红的代表当前为一个字符串的最后一个结点

```cpp
const int N = 1000050;
int trie[N][26];
int cnt[N];
int id;

void insert(string s)
{
	int p = 0;
	for (int i = 0; i < s.size(); i++)
	{
		int x = s[i] - 'a';
		if (trie[p][x] == 0) trie[p][x] = ++id;
		p = trie[p][x];
	}
	cnt[p]++;
}

int  find(string s)
{
	int p = 0;
	for (int i = 0; i < s.size(); i++)
	{
		int x = s[i] - 'a';
		if (trie[p][x] == 0)return 0;
		p = trie[p][x];
	}
	return cnt[p];
}
```







### 普通平衡树

```cpp
int RD(){
    int out = 0,flag = 1;char c = getchar();
    while(c < '0' || c >'9'){if(c == '-')flag = -1;c = getchar();}
    while(c >= '0' && c <= '9'){out = out * 10 + c - '0';c = getchar();}
    return flag * out;
    }
//第一次打treap，不压行写注释XD
const int maxn = 1000019,INF = 1e9;
//平衡树，利用BST性质查询和修改，利用随机和堆优先级来保持平衡，把树的深度控制在log N，保证了操作效率
//基本平衡树有以下几个比较重要的函数：新建，插入，删除，旋转
//节点的基本属性有val(值)，dat(随机出来的优先级)
//通过增加属性，结合BST的性质可以达到一些效果，如size(子树大小，查询排名)，cnt(每个节点包含的副本数)等
int na;
int ch[maxn][2];//[i][0]代表i左儿子，[i][1]代表i右儿子
int val[maxn],dat[maxn];
int size[maxn],cnt[maxn];
int tot,root;
int New(int v){//新增节点，
	val[++tot] = v;//节点赋值
	dat[tot] = rand();//随机优先级
	size[tot] = 1;//目前是新建叶子节点，所以子树大小为1
	cnt[tot] = 1;//新建节点同理副本数为1
	return tot;
	}
void pushup(int id){//和线段树的pushup更新一样
	size[id] = size[ch[id][0]] + size[ch[id][1]] + cnt[id];//本节点子树大小 = 左儿子子树大小 + 右儿子子树大小 + 本节点副本数
	}
void build(){
	root = New(-INF),ch[root][1] = New(INF);//先加入正无穷和负无穷，便于之后操作(貌似不加也行)
	pushup(root);//因为INF > -INF,所以是右子树，
	}
void Rotate(int &id,int d){//id是引用传递，d(irection)为旋转方向，0为左旋，1为右旋
	int temp = ch[id][d ^ 1];//旋转理解：找个动图看一看就好(或参见其他OIer的blog)
	ch[id][d ^ 1] = ch[temp][d];//这里讲一个记忆技巧，这些数据都是被记录后马上修改
	ch[temp][d] = id;//所以像“Z”一样
	id = temp;//比如这个id，在上一行才被记录过，ch[temp][d]、ch[id][d ^ 1]也是一样的
	pushup(ch[id][d]),pushup(id);//旋转以后size会改变，看图就会发现只更新自己和转上来的点，pushup一下,注意先子节点再父节点
	}//旋转实质是({在满足BST的性质的基础上比较优先级}通过交换本节点和其某个叶子节点)把链叉开成二叉形状(从而控制深度)，可以看图理解一下
void insert(int &id,int v){//id依然是引用，在新建节点时可以体现
	if(!id){
		id = New(v);//若节点为空，则新建一个节点
		return ;
		}
	if(v == val[id])cnt[id]++;//若节点已存在，则副本数++;
	else{//要满足BST性质，小于插到左边，大于插到右边
		int d = v < val[id] ? 0 : 1;//这个d是方向的意思，按照BST的性质，小于本节点则向左，大于向右
		insert(ch[id][d],v);//递归实现
		if(dat[id] < dat[ch[id][d]])Rotate(id,d ^ 1);//(参考一下图)与左节点交换右旋，与右节点交换左旋
		}
	pushup(id);//现在更新一下本节点的信息
	}
void Remove(int &id,int v){//最难的部分了
	if(!id)return ;//到这了发现查不到这个节点，该点不存在，直接返回
	if(v == val[id]){//检索到了这个值
		if(cnt[id] > 1){cnt[id]--,pushup(id);return ;}//若副本不止一个，减去一个就好
		if(ch[id][0] || ch[id][1]){//发现只有一个值，且有儿子节点,我们只能把值旋转到底部删除
			if(!ch[id][1] || dat[ch[id][0]] > dat[ch[id][1]]){//当前点被移走之后，会有一个新的点补上来(左儿子或右儿子)，按照优先级，优先级大的补上来
				Rotate(id,1),Remove(ch[id][1],v);//我们会发现，右旋是与左儿子交换，当前点变成右节点；左旋则是与右儿子交换，当前点变为左节点
				}
			else Rotate(id,0),Remove(ch[id][0],v);
			pushup(id);
			}
		else id = 0;//发现本节点是叶子节点，直接删除
		return ;//这个return对应的是检索到值de所有情况
		}
	v < val[id] ? Remove(ch[id][0],v) : Remove(ch[id][1],v);//继续BST性质
	pushup(id);
	}
int get_rank(int id,int v){
	if(!id)return 0;//若查询值不存在，返回；因为最后要减一排除哨兵节点，想要结果为-1这里就返回0
	if(v == val[id])return size[ch[id][0]] + 1;//查询到该值，由BST性质可知：该点左边值都比该点的值(查询值)小，故rank为左儿子大小 + 1
	else if(v < val[id])return get_rank(ch[id][0],v);//发现需查询的点在该点左边，往左边递归查询
	else return size[ch[id][0]] + cnt[id] + get_rank(ch[id][1],v);//若查询值大于该点值。说明询问点在当前点的右侧，且此点的值都小于查询值，所以要加上cnt[id]
	}
int get_val(int id,int rank){
	if(!id)return INF;//一直向右找找不到，说明是正无穷
	if(rank <= size[ch[id][0]])return get_val(ch[id][0],rank);//左边排名已经大于rank了，说明rank对应的值在左儿子那里
		else if(rank <= size[ch[id][0]] + cnt[id])return val[id];//上一步排除了在左区间的情况，若是rank在左与中(目前节点)中，则直接返回目前节点(中区间)的值
	else return get_val(ch[id][1],rank - size[ch[id][0]] - cnt[id]);//剩下只能在右区间找了，rank减去左区间大小和中区间，继续递归
	}
int get_pre(int v){
	int id = root,pre;//递归不好返回，以循环求解
	while(id){//查到节点不存在为止
		if(val[id] < v)pre = val[id],id = ch[id][1];//满足当前节点比目标小，往当前节点的右侧寻找最优值
		else id = ch[id][0];//无论是比目标节点大还是等于目标节点，都不满足前驱条件，应往更小处靠近
		}
	return pre;
	}
int get_next(int v){
	int id = root,next;
	while(id){
		if(val[id] > v)next = val[id],id = ch[id][0];//同理，满足条件向左寻找更小解(也就是最优解)
		else id = ch[id][1];//与上方同理
		}
	return next;
	}
int main(){
	build();//不要忘记初始化[运行build()会连同root一并初始化，所以很重要]
	na = RD();
	for(int i = 1;i <= na;i++){
		int cmd = RD(),x = RD();
		if(cmd == 1)insert(root,x);//函数都写好了，注意：需要递归的函数都从根开始，不需要递归的函数直接查询
		else if(cmd == 2)Remove(root,x);
		else if(cmd == 3)printf("%d\n",get_rank(root,x) - 1);//注意：因为初始化时插入了INF和-INF,所以查询排名时要减1(-INF不是第一小，是“第零小”)
		else if(cmd == 4)printf("%d\n",get_val(root,x + 1));//同理，用排名查询值得时候要查x + 1名，因为第一名(其实不是)是-INF
		else if(cmd == 5)printf("%d\n",get_pre(x));
		else if(cmd == 6)printf("%d\n",get_next(x));
		}
	return 0;
}
```





### 笛卡尔树



```cpp
  for(int i=1;i<=n;i++){
        a[i]=read();
        while(a[sta[top]]>a[i]&&top) son[i][0]=sta[top--];
        if(sta[top]) son[sta[top]][1]=i;
        sta[++top]=i;
    }
    for(int i=1;i<=n;i++){
        lans=lans^(i*(son[i][0]+1));
        rans=rans^(i*(son[i][1]+1));
    }
```



## 动态规划

### 暴力DP

#### 背包问题

##### 分组背包

若干组物品，每组中的物品互相冲突（就是说每组中最多只能选一件物品），求最大价值。

伪代码：

```cpp
for(int k=1;k<=总共的组数;k++)//遍历所有的组k
	for(int j=v;j>=1;j--)//跟01背包类似，倒序枚举背包容量
    	for(int i=1;i<=组中的元素个数;i++)//遍历这组中所有的元素
        
        
//另一个版本的伪代码
        
for (int i = 0到组数)
	for (int j = max_v到0)
		for (int k = 此组所有物品)
			f[j] = max (f[j], f[j - v[k]] + w[k])
```



#### 状压DP

利用二进制数表示状态，通过枚举所有状态进行动态规划。



#### 区间DP

>  区间dp就是在区间上进行**动态规划**，求解一段区间上的最优解。主要是通过合并小区间的 最优解进而得出整个大区间上最优解的dp算法。

**核心思路**：要求一个大区间中的最优解，只需要把这个很大的区间不断分割，变成很小的一个个区间，求出每个小区间的最优解，然后合并起来，最终找出完整区间的最优解即可。

```cpp
for(int len = 1;len<=n;len++){//枚举长度
        for(int j = 1;j+len<=n+1;j++){//枚举起点，ends<=n
            int ends = j+len - 1;
            for(int i = j;i<ends;i++){//枚举分割点，更新小区间最优解
                dp[j][ends] = min(dp[j][ends],dp[j][i]+dp[i+1][ends]+something);
            }
        }
}
```



#### 数位DP



### 树形DP🌟

[博客](https://blog.csdn.net/m0_59459037/article/details/119189656)

从根节点出发，向子节点做深度优先搜索，并由其子节点的最优解合并得到该节点的最优解。

**好图**

[![vghfEQ.png](https://s1.ax1x.com/2022/08/25/vghfEQ.png)](https://imgse.com/i/vghfEQ)

#### 树上动态规划





#### 树上01背包





#### 树上多重背包





#### 换根DP

基于树上DP，但是题目不给出哪个点是根结点，因此遍历一边所有的点从而达到某一个点作为根结点的最佳情况。

如果暴力做，复杂度为 $O(n^2)$ ,利用换根DP，可降至`O(n)`

**思路**：

第一遍**dfs** 预处理出状态，第二遍通过 **dfs** 遍历树中每个节点，对每个结点根据推导式得出结果。 



```cpp
void dfs1(int x, int fa) //用来搜索出每个节点的深度和它的子树的大小
{

    size[x] = 1;
    dep[x] = dep[fa] + 1;
    for (int i = head[x]; i; i = e[i].next)
    {
        int v = e[i].to;
        if (v == fa)
            continue;
        dfs1(v, x);
        size[x] += size[v];
    }
}
void dfs2(int x, int fa) //用来不断转移根节点来找到答案
{
    for (int i = head[x]; i; i = e[i].next)
    {
        int v = e[i].to;
        if (v == fa)
            continue;

        f[v] = f[x] + n - size[v] * 2;
        dfs2(v, x);
    }
}
```



#### 虚树

 一次询问只涉及到整棵树中的少量结点时，可以建立一颗包含关键节点的树，称为**虚树** 

舍去很多无用的结点，可以将时间复杂度降到`O(nlogn)`

[![voMgDP.png](https://s1.ax1x.com/2022/09/03/voMgDP.png)](https://imgse.com/i/voMgDP)

两个关键节点之前的连接点就是他们的**最近公共祖先（LCA）**

**建立虚树**

**一**：存图，预处理`dfs`序

```cpp
void dfs1(int pos)
{
    int k;
    for (k = 0; fa[pos][k]; k++)   //用于之后倍增求LCA
    {
        fa[pos][k + 1] = fa[fa[pos][k]][k];
    }
    logmax[pos] = k; //记录最大2的倍数
    dfn[pos] = ++id; //时间戳
    for (int i = head1[pos]; i; i = e1[i].nex)
    {
        int to = e1[i].to;
        if (!dfn[to]) // 没有处理过该点
        {
            deep[to] = deep[pos] + 1;
            minv[to] = min(minv[pos], e1[i].w);
            fa[to][0] = pos;
            dfs1(to);
        }
    }
}
```



**二** 根据四种情况进行处理，将正在处理的链称作**“最右链”**

第一种情况：

[![v7kLSx.png](https://s1.ax1x.com/2022/09/05/v7kLSx.png)](https://imgse.com/i/v7kLSx)

第二种情况：

![image-20220905203533372](C:\Users\hy020\AppData\Roaming\Typora\typora-user-images\image-20220905203533372.png)

第三种情况：

![image-20220905203605983](C:\Users\hy020\AppData\Roaming\Typora\typora-user-images\image-20220905203605983.png)

第四种情况：

![image-20220905203620294](C:\Users\hy020\AppData\Roaming\Typora\typora-user-images\image-20220905203620294.png)

```cpp
st[top = 1] = lst[1];         //将第一个节点入栈
for (int i = 2; i <= num; i++)   //处理之后每一个结点
        {
            int now = lst[i];
            int lc = lca(now, st[top]);
            while (1)
            {
                if (deep[lc] >= deep[st[top - 1]])
                {
                    if (lc != st[top])
                    {
                        add2(lc, st[top]);
                        if (lc != st[top - 1])
                            st[top] = lc;
                        else
                            top--;
                    }
                    break;
                }
                else // 4
                {
                    add2(st[top - 1], st[top]);
                    top--;
                }
            }
            st[++top] = now;
        }
```



### DP优化

#### 单调队列优化

> 单调队列，即单调递减或单调递增的[队列](https://so.csdn.net/so/search?q=队列&spm=1001.2101.3001.7020)。













## 图论

### 单源最短路径

![vro8Og.png](https://s1.ax1x.com/2022/08/19/vro8Og.png)

#### Floyd

**思想** ：枚举

时间复杂度：$O(n^3)$   ，    空间复杂度： $O(n^2)$

**适用条件** ： 不能有负环，且必须存在最短路

```c++
for(int k = 1; k <= n; k++){
    for(int x = 1; x <= n; x++){
        for(int y = 1; y <= n; y++){
            f[x][y]= min(f[x][y], f[x][k]+f[k][y]);
        }
    }
}
```



#### SPFA

[博客](https://blog.csdn.net/qq_39670434/article/details/78464995)

##### 最短路

**思路**：由一个点不断扩展子节点，如果能够进行迭代，那么入队，被入队的点再进行扩展....

```cpp
void SPFA()
{
    for(int i=1;i<=n;i++)
    {
        dis[i]=maxint;
        vis[i]=false;
    }
    dis[s]=0;
    vis[s]=true;
    int u;
    q.push(s);
    while(!q.empty())
    {
        u=q.front();
        for(int i=head[u];i;i=e[i].nxt)
        	if(dis[u]+e[i].len<dis[e[i].to])
        	{
            	dis[e[i].to]=dis[u]+e[i].len;
            	if(vis[e[i].to]==false)
            	{
                	vis[e[i].to]=true;
                	q.push(e[i].to);
            	}
        	}
        vis[q.front()]=false;
      	q.pop();
    }
}
```



##### 负环

每次入队的时候记录一下

```cpp
bool SPFA() {
    dis[1] = 0;
    vis[1] = true;
    q.push(1);
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        vis[u] = false;
        for (int i = head[u]; i; i = e[i].nex) {
            int to = e[i].to;
            if (e[i].val + dis[u] < dis[to]) {
                dis[to] = dis[u] + e[i].val;
                if (!vis[to]) {
                    q.push(to);
                    vis[to] = true;
                  	cnt[to] = cnt[u] + 1;
                		if (cnt[to] >= n) return true;  //如果该点入队次数>=n,则有负环。
                }
            }
        }
    }
    return false;
}
```



#### Dijkstra

**思想** ：类似于 Prim ，不断找到耗费最小的点，进行标记，直到达到目标

时间复杂度： $O(n^2)$    ，  空间复杂度： $O(m log m)$

```c++
const int inf=0x3f3f3f3f; //代表无穷大。
const int maxn=100;//最大顶点数
int n,m;//n个顶点，m条边。
bool visited[maxn];//判断是否确定到源点的最终最短距离。
int graph[maxn][maxn];//带权图
int dis[maxn];//顶点到源点的最短距离。
int start,goal;//起点与目标点。


void init(){
	memset(visited,false,sizeof(visited));
	for(int i=1;i<=n;i++){
		dis[i]=graph[start][i];//初始化dis数组。
	}
}


void dijkstra(){
	//源点为源点start。
	int minn;//记录每趟最短路径中最小的路径值。 
	int pos;//记录得到的minn所对应的下标。
	init();//调用初始化函数。
	visited[start]=true;
	for(int i=1;i<=n;i++){
		//将n个顶点依次加入判断。
		minn=inf;
		for(int j=1;j<=n;j++){
			if(!visited[j]&&dis[j]<minn){
				minn=dis[j];
				pos=j;
			}
		}
		//经过这趟for循环后我们找到的就是我们想要的点，可以确定这点到源点的最终最短距离了。
		visited[pos]=true;//我们将此点并入已知集合。
		//接下来就是更新dis数组了，也就是当前最短距离，这都是针对还没有并入已知集合的点。
		for(int j=1;j<=n;j++){
			if(!visited[j]&&dis[j]>dis[pos]+graph[pos][j])
				dis[j]=dis[pos]+graph[pos][j];
		}
	}
	//退出循环后，所有的点都已并入已知集合中，得到的dis数组也就是最终最短距离了。
	cout<<dis[goal]<<endl;//输出目标点到源点的最短路径长度。
}

```



##### 优先队列优化版

**思想** ：利用最小堆维护最小值，不用再去循环枚举找出最小值。

**时间复杂度**：$MlogM$

```cpp
typedef pair<int,int> pdd;

int head[maxn], dis[maxn];
bool vis[maxn];

struct Edge{
    itn u,v,w;
    int nex;
}e[maxm];

inline void add(int a,int b,int c)
{
    e[++cnt].u=a;
    e[cnt].v=b;
    e[cnt].w=c;
    e[cnt].nex=head[a];
    head[a]=cnt;
}

priority_queue<pdd,vector<pdd>,greater<pdd>> q;

void dijkstra()
{
    while(!empty())
    {
        pdd t = q.top();
        q.pop();
        int now = t.second;
        if(vis[now])
            continue;
        vie[now]=true;
        
        for(int i = head[now]; i; i = e[i].nex)
        {
            int to = e[i].v;
            if(dis[to]>dis[now]+e[i].w)
            {
                dis[to]= dis[now] + e[i].w;
                q.push({dis[to],to});
            }
        }
    }
    
}
```



### 树上问题

#### 最近公共祖先（LCA）

博客[链接](https://blog.csdn.net/qq_43332980/article/details/107437070?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-107437070-blog-121195470.pc_relevant_multi_platform_featuressortv2removedup&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-107437070-blog-121195470.pc_relevant_multi_platform_featuressortv2removedup)

##### 倍增（在线）

**复杂度**

预处理：`O(nlogn)`

单次查询：`O(logn)`

总复杂度：`O(nlogn+mlogn)`

**实现**

采用`f[x][i]`数组来表示点 x 的第 $2^i$ 个祖先

```cpp
//预处理f数组
for(int i=1;(i<<i)<d[u];i++)
{
  	f[u][i] = f[f[u][i-1]][i-1];
}
```

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAX_N = 500000+7, MAX_M = 500000+7;

int n,m,s;
int d[MAX_N]; //保存节点深度
int f[MAX_N][21]; //保存节点的不同倍数的父节点

int head[MAX_N], cnt=-1;
struct Edge{
    int to , next;
}e[MAX_N*2];

void add(int u,int v){
    e[++cnt].to = v;
    e[cnt].next = head[u];
    head[u] = cnt;
}

void dfs(int u,int fa) // u为当前节点,fa为父节点
{
    f[u][0] = fa;
    d[u] = d[fa]+1;

    for(int i=1;(1<<i)<=d[u];i++)
        f[u][i] = f[f[u][i-1]][i-1];    //预处理f数组

    for(int i=head[u];i!=-1;i=e[i].next){
        int v = e[i].to;
        if(v!=fa)
            dfs(v,u);
    }
}

int lca(int x,int y)
{
    if(d[x]>d[y])  //令y为更深节点
    	swap(x,y);
    
    for(int i=20;i>=0;i--){   //这里使得x与y处于同一深度
        if(d[x]<=d[y]-(1<<i))
            y=f[y][i];
    }

    //特判
    if(x==y)
        return x;
    
    for(int i=20;i>=0;i--)
    {
        if(f[x][i]==f[y][i])
            continue;              //这里是从最远的公共祖先开始找，所以需要continue
        else
            x=f[x][i],y=f[y][i];   //上跳
    }

    return f[x][0];
}

int main()
{
    memset(head,-1,sizeof(head));
    int a,b;
    scanf("%d%d%d",&n,&m,&s);
    for(int i=1;i<n;i++)
    {
        scanf("%d%d",&a,&b);
        add(a,b);
        add(b,a);                      //无向图，要加两次
    }
    dfs(s,0);

    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&a,&b);
        printf("%d\n",lca(a,b));
    }

    return 0;
}

```



##### ST+RMQ(在线)

**复杂度**

预处理：`O(logn)`

查询：`O(1)`

总复杂度：`O(nlogn+m)`

**原理**

将一棵树转为dfs序后，也就是说dfs序的一段区间是原树的一棵子树。

而要查找两个点的最近公共祖先，只要找dfs序中两个点之间深度最小的那个点即可。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAX_N = 500000+7, MAX_M = 500000+7;

int n,m,s;

//dfs序数组
int tot = 0;
int fir[MAX_N];
int dfn[MAX_N*2];
int d[MAX_N*2];

//ST表数组
int st[20][MAX_N*2];   //st表
int ist[20][MAX_N*2];  //记录最值下标
int Log[MAX_N*2];

void getLog()
{
	Log[1] = 0;
	for(int i=2;i<=MAX_N*2;i++)
		Log[i] = Log[i/2]+1;
}

void init()
{
    for(int i=1;i<=tot;i++){
        st[0][i]=d[i];
        ist[0][i] = dfn[i];
    }
    for(int j=1;(1<<j)<=tot;j++){
		for(int i=1;i+(1<<(j-1))<=tot;i++){
            if(st[j-1][i]<st[j-1][i+(1<<(j-1))]){
                st[j][i] = st[j-1][i];
                ist[j][i] = ist[j-1][i];
            }else{
                st[j][i] = st[j-1][i+(1<<(j-1))];
                ist[j][i] = ist[j-1][i+(1<<(j-1))];
            }
        }
    }

    getLog();
}

int Query(int l,int r)
{
	int k=Log[r-l+1];
	int ans;

    if(st[k][l]<st[k][r-(1<<k)+1]) 
        ans = ist[k][l];
    else 
        ans = ist[k][r-(1<<k)+1];

    return ans;
}


int head[MAX_N], cnt=-1;
struct Edge{
    int to , next;
}e[MAX_N*2];

void add(int u,int v){
    e[++cnt].to = v;
    e[cnt].next = head[u];
    head[u] = cnt;
}

void dfs(int u,int dep) // u为当前节点,dep为深度
{
    fir[u] = ++tot;
    dfn[tot] = u;
    d[tot] = dep;

    for(int i=head[u];i!=-1;i=e[i].next){
        int v = e[i].to;
        if(!fir[v]){
            dfs(v,dep+1);
            dfn[++tot]=u;
            d[tot]=dep;
        }
    }
}


int lca(int x,int y)
{
    int l = fir[x] , r = fir[y];
    if(l>r) swap(l,r);
    return Query(l,r);
}


int main()
{
    memset(head,-1,sizeof(head));
    int a,b;
    scanf("%d%d%d",&n,&m,&s);
    for(int i=1;i<n;i++)
    {
        scanf("%d%d",&a,&b);
        add(a,b);
        add(b,a);                      //无向图，要加两次
    }
    dfs(s,0);
    init();

    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&a,&b);
        printf("%d\n",lca(a,b));
    }

    return 0;
}

```

##### Tarjan（离线） 存在问题，洛谷模板过不了

**思路**

+ 任选一个点u为根节点，开始遍历
+ 遍历所有的子节点v，并进行标记
+ 若有子节点v还有子节点，那么重复第二步，继续遍历
+ 合并v到u上（使用并查集）
+ 寻找与u有关系的查询节点v
+ 若v已被访问过，则可以直接求出LCA，即为v被合并到的父亲结点

**伪代码**：

```cpp
Tarjan(u)//marge和find为并查集合并函数和查找函数
{
    for each(u,v)    //访问所有u子节点v
    {
        Tarjan(v);        //继续往下遍历
        marge(u,v);    //合并v到u上
        标记v被访问过;
    }
    for each(u,e)    //访问所有和u有询问关系的e
    {
        如果e被访问过;
        u,e的最近公共祖先为find(e);
    }
}
```

```cpp
void Tarjan(int u,int fa) // u为当前节点,fa为父节点
{

    for(int i=head[u];i!=0;i=e[i].next){
        int v = e[i].to;
        if(v!=fa&&!vis[v]){
            Tarjan(v,u);
            unionn(u,v);   // 注意这里位置不能交换， 原树上u为v的父节点
            vis[v]=true;   // 标记访问
        }
    }

    for(int i=que[u];i!=0;i=q[i].next){
        int v = q[i].to;
        if(!q[i].flag&&vis[v]){
            ans[q[i].num] = find(v);
            q[i].flag = true;           //完成询问则把镜像问题也打上标记
            q[q[i].same].flag = true;
        }
    }
}
```





### 最小生成树

**定义** ：对带权**联通**无向图G，生成一棵权值最小的树。

**性质**：

+ 可能含有多个最小生成树，但是最小权值之和唯一。
+ 边数=点数 - 1



#### Prim

**思想** ：从一个顶点开始构建，每次将花费最小的新顶点加入，直到所有顶点都加入。

**时间复杂度** ：$O(\mid V \mid ^2)$   ，适用于稠密图

```cpp
//Prim
int maxn;  //最大结点数
int INF = 1000000000;
int dis[maxn]; //顶点与集合中任一点的最短距离
bool vus[maxn]; //是否已加入
int Prim()
{
    fill(dis,dis+maxn,INF);   //初始化dis数组为INF
    dis[0]=0;   //选择0号结点加入，则只有0号节点距离为0
    int ans = 0;  //由于一开始只有一个结点，没有边，所以边权之和为0
    for(int i=0;i<n;i++)
    {
        int u = -1;
        int minn = INF;
        for(int j=0;j<n;j++)
        {
            if(!vis[j] && dis[j]<minn)  //没被访问过且距离最短
            {
                u = j;
                minn = dis[j];
            }
        }
        if(u==-1) //没有找到
        	reutnr -1;
       	
        vis[u]=1;
        ans+=dis[u];
        for(int v = 0; v<n; v++)
        {
            if(!vis[v] && a[u][v]!=INF && a[u][v]<dis[v])
            {
                dis[v]=a[u][v];
            }
        }
    }
    
    
}
```




#### Kruskal

**思想** ：每次选择权值最小的边加入，且两个端点没有联通，直到所有结点都联通

**时间复杂度** ：$O(\textbar E \textbar log_2\textbar E \textbar)$

```cpp
    //Kruskal

    struct Edge{
        int u;
        int v;
        int w;
    }e[maxm];
    bool cmp(Edge p,Edge q)
    {
        return p.w<q.w;
    }

    int find(int x)
    {

        if(fa[x]!=x)
        {
            fa[x]=find(fa[x]);
        }
        return fa[x];
    }

    void Kruskal()
    {
        sort(e+1,e+m+1,cmp);
        for(int i=1;i<=m;i++)
        {
            int faa = find(e[i].u);
            int fab = find(e[i].v);
            if(faa == fab)
                continue;
            fa[fab]=faa;
            ans+=e[i].w;
            if(++cnt == n-1)
                break;
        }
    }
```

### 拓扑排序

#### 思路

将一个图中的入度为0的点选取出来，然后把它指向点所有的点入度减一，不断重复这个操作，依次顺序便是**拓扑排序**的顺序。

#### 复杂度

`O(V+E)`

```cpp
    queue<int>q;
    vector<int>edge[n];
    for(int i=0;i<n;i++)  //n  节点的总数
        if(in[i]==0) q.push(i);  //将入度为0的点入队列
    vector<int>ans;   //ans 为拓扑序列
    while(!q.empty())
    {
        int p=q.front(); q.pop(); // 选一个入度为0的点，出队列
        ans.push_back(p);
        for(int i=0;i<edge[p].size();i++)
        {
            int y=edge[p][i];
            in[y]--;
            if(in[y]==0)
                q.push(y);  
        }
    }
    if(ans.size()==n)   
    {
        for(int i=0;i<ans.size();i++)
            printf( "%d ",ans[i] );
        printf("\n");
    }
    else printf("No Answer!\n");   //  ans 中的长度与n不相等，就说明无拓扑序列

```

### 差分约束系统

由多个不等式组成，比如 `i-j<k` ，可以建立一条从`j`到`i`，边长为`k` 的边。

关于为什么差分约束系统可以转换为最短路问题：

[![vcA0Qx.png](https://s1.ax1x.com/2022/08/23/vcA0Qx.png)](https://imgse.com/i/vcA0Qx)

要满足所有的条件，因此 C - A 可能同时需要满足小于10，小于5，这时候一定要满足小于5，如果大于5那这个条件就不满足了。

```cpp
bool spfa(int x) {
    dis[x] = 0;
    vis[x] = true;
    q.push(x);
    num[x]++;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        vis[u] = false;
        for (int i = head[u]; i; i = e[i].nex) {
            int to = e[i].to;
            if (dis[u] + e[i].val < dis[to]) {
                dis[to] = dis[u] + e[i].val;
                if (!vis[to]) {
                    q.push(to);
                    vis[to] = true;
                    num[to]++;
                    if (num[to] == n + 1)return false;  //判断是否有负环，如果有负环则入队次数>n，则无解。
                }
            }
        }
    }
    return true;
}
```



### 连通性

[博客](https://blog.csdn.net/qq_25930891/article/details/123208901)

**强连通分量**

在一个图G中，若两个点互相可到达，则称该两点**强连通**，若该图中每两个点之间都是强连通，则该图为一个**强连通图**。

有向非强连通图的极大强连通子图，称为**强连通分量** 。

**作用**

降低图的规模，从而减小图的复杂度。

#### Tarjan算法

可以找出一个图中所有的强连通分量。

不断`dfs`搜索，遇到环则进行更新，然后返回。

```cpp
void tarjan(int x) {
    s.push(x);
    instack[x] = 1;	
    
    dfn[x] = low[x] = ++cnt; //初始化dfn和low
    
    //核心代码，深搜这个点
    for (int i = head[x]; i; i = edge[i].next) {
        int to = edge[i].to;
        if(!dfn[to]){	//如果下一个点没有被搜过，
            tarjan(to);	//继续深搜
            low[x] = min(low[x], low[to]); //更新low
        }
        else if(instack[to]){ //如果下一个点已经被搜过，看他在不在栈里
            low[x] = min(low[x], dfn[to]); //更新low
        }
    }
    //如果dfn==low，即找完了一整块强连通分量，出栈+标记
    if(dfn[x] == low[x]){
        tot++;//计数器++，第几个强连通分量
        while(s.top()!=x){ 		//不加1的话x这个点不会被出栈
            scc[s.top()] = tot;	//打标记
            instack[s.top()]=0;
            s.pop();//出栈
        }
    }
}


```



#### 缩点

[博客](https://blog.csdn.net/ez_gsn/article/details/122898581?spm=1001.2101.3001.6650.7&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-7-122898581-blog-93732524.pc_relevant_multi_platform_featuressortv2dupreplace&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-7-122898581-blog-93732524.pc_relevant_multi_platform_featuressortv2dupreplace&utm_relevant_index=8)

就是把原本的环缩到一个点上，这样的话图中所有的环都消失了

```cpp
void search (int u)
{
	if (f[u]) return;
	f[u] = sum[u];
	int maxsum = 0;
	for (int i = hd[u]; i; i = e[i].nxt)
	{
		int v = e[i].to;
		if (!f[v]) search (v);
		maxsum = max (maxsum, f[v]);
	}
	f[u] += maxsum;
}


```



#### 割点

⚠️ 仅针对无向图

**连通** ：图中任意两个点之间可互相到达

**割点**：在一个**无向图**里，去掉一个顶点，及其去掉该点的所有边,剩下的图不连通，那么这个点就是个**割点**。

**割边**：在一个**无向图**里，去掉一条边，图就不连通了。

```cpp
#include <iostream>

using namespace std;
const int maxn = 1000005;
int low[maxn], dfn[maxn], head[maxn];
bool f[maxn];
int n, m, ans, cnt, id;
struct Edge {
    int to;
    int nex;
} e[maxn << 1];

void add(int x, int y) {
    e[++cnt].to = y;
    e[cnt].nex = head[x];
    head[x] = cnt;
}

void dfs(int u, int root) {
    low[u] = dfn[u] = ++id;
    int tot = 0;
    for (int i = head[u]; i; i = e[i].nex) {
        int v = e[i].to;
        if (!dfn[v]) {
            dfs(v, root);
            low[u] = min(low[u], low[v]);
            if (low[v] >= dfn[u] && u != root)
                f[u] = true;
            if (u == root) tot++;
        }
        low[u] = min(low[u], dfn[v]);

    }
    if (tot >= 2 && root == u)
        f[root] = true;
}

int main() {
    cin >> n >> m;
    int x, y;
    for (int i = 1; i <= m; i++) {
        cin >> x >> y;
        add(x, y);
        add(y, x);
    }
    for (int i = 1; i <= n; i++) {
        if (!dfn[i])
            dfs(i, i);
    }
    for (int i = 1; i <= n; i++)
        if (f[i])
            ans++;
    cout << ans<<endl;
    for (int i = 1; i <= n; i++)
        if (f[i])
            cout << i << ' ';
}
```



### 二分图

[博客](https://blog.csdn.net/weixin_51797626/article/details/122129473)

**定义**

如下图所示，一张图中的所有的点能分成两个集合，集合内部的点之间没有边，只有属于两个不同的集合的点才可能存在边，这样的图叫做**二分图**

[![vbid91.png](https://s1.ax1x.com/2022/09/07/vbid91.png)](https://imgse.com/i/vbid91)

**最大匹配数** ：两个集合分别选一个点，这两个点之间有边就确认一段关系（一个集合中的两点 占有 另一集合中同一个点 是不合法的），最多的关系数量就是这张二分图的最大匹配

**最小点覆盖**：在一个图中选取最少个点，使得其他所有的边都与选中的点相连

 ------------**最大匹配数 == 最小点覆盖** ---------------



#### 匈牙利算法--无权值最大匹配

时间复杂度：`O(nm)`

本质：寻找增广路以达到最大匹配情况

```cpp
bool dfs(int x)
{
    for (int i = 1; i <= n; i++)   //遍历左边集合所有点
    {
        if (!vis[i] && match[i][x])  //如果存在边并且该点没有访问过，那么就进行操作
        {
            vis[i] = 1;             //标记该点为已访问
            if (id[i] == 0 || dfs(id[i]))  //如果该点之前没有边连接，那么就连接，如果有的话，dfs这个点，看看是否能够找到其他的增广路
            {
                id[i] = x;
                return true;
            }
        }
    }
    return false;
}
```







### 网络流

[![vLNFJJ.png](https://s1.ax1x.com/2022/09/09/vLNFJJ.png)](https://imgse.com/i/vLNFJJ)

#### 最大流

##### **Dinic**

时间复杂度：$O(v^2e)$

**思路** ：先用`BFS` 分层，预处理出源点到每个点的距离（注意每次循环都要预处理一次，因为有些边可能容量变为0不能再走），再使用**多路增广** 节省花在重复路径上的时间（在某点`DFS`找到一条增广路之后，如果还剩下多余的流量没有用，继续在这个点`DFS`尝试寻找更多增广路。

**当前弧优化** ：在**Dinic**算法中，一条边增广一次后就不会再次增广了，所以下次增广时不需要再考虑这条边。我们把`head`数组复制一份，但不断更新增广的起点。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

const int N = 10010, E = 200010;

int n, m, s, t; LL ans = 0;
LL cnt = 1, first[N], nxt[E], to[E], val[E];
inline void addE(int u, int v, LL w) {
	to[++cnt] = v;
	val[cnt] = w;
	nxt[cnt] = first[u];
	first[u] = cnt;
}
int dep[N], q[N], l, r;
bool bfs() {//顺着残量网络，方法是 bfs；这是个bool型函数，返回是否搜到了汇点 
	memset(dep, 0, (n + 1) * sizeof(int));//记得开局先初始化 

	q[l = r = 1] = s;
	dep[s] = 1;
	while(l <= r) {
		int u = q[l++];
		for(int p = first[u]; p; p = nxt[p]) {
			int v = to[p];
			if(val[p] and !dep[v]) {//按照有残量的边搜过去 
				dep[v] = dep[u] + 1;
				q[++r] = v;
			}
		}
	}
	return dep[t];//dep[t] != 0，就是搜到了汇点 
}
LL dfs(int u, LL in/*u收到的支持（不一定能真正用掉）*/) {
//注意，return 的是真正输出的流量
	if(u == t)
		return in;//到达汇点是第一个有效return 
	LL out = 0;
	for(int p = first[u]; p and in; p = nxt[p]) {
		int v = to[p];
		if(val[p] and dep[v] == dep[u] + 1) {//仅允许流向下一层 
			LL res = dfs(v, min(val[p], in)/*受一路上最小流量限制*/);
			//res是v真正输出到汇点的流量
			val[p] -= res;
			val[p ^ 1] += res;
			in -= res;
			out += res;
		}
	}
	if(out == 0)//我与终点（顺着残量网络）不连通 
		dep[u] = 0;//上一层的点请别再信任我，别试着给我流量
	return out;
}
int main() {
	scanf("%d %d %d %d", &n, &m, &s, &t);
	for(int i = 1; i <= m; ++i) {
		int u, v; LL w;
		scanf("%d %d %lld", &u, &v, &w);
		addE(u, v, w);
		addE(v, u, 0);
	}
	while(bfs()) 
		ans += dfs(s, 1e18);
	printf("%lld\n", ans);
	return 0;
}
```



##### 预流推进--HLPP

HLPP--- 最高标号预流推进算法





#### 最小割

**割**：从网络中选择一些边，使得去掉这些边后，剩下两个不连通的分别包含源点和汇点的点集。去掉的这些边的权值之和就是**割**。

:star:**最大流=最小割**



#### 费用流



#### 上下界网络流







### 树链剖分

[![volCWQ.png](https://s1.ax1x.com/2022/09/03/volCWQ.png)](https://imgse.com/i/volCWQ)

**使用场景**

+ 从子节点到根结点到路程中 操作
+ 从根节点到其所有子节点 操作

概念：**重儿子** --- 一个节点中子树最大的儿子。

**实现**

**DFS1**

处理事情：

+ 标记每个点的深度`deep`
+ 标记每个点的父亲`fa`
+ 标记每个点非叶子结点的子树大小（包含自身）`size`
+ 标记每个非叶子结点的重儿子`son`

```cpp
void dfs1(int x, int f, int deep)
{                    // x当前节点，f父亲，deep深度
    dep[x] = deep;   //标记每个点的深度
    fa[x] = f;       //标记每个点的父亲
    siz[x] = 1;      //标记每个非叶子节点的子树大小
    int maxson = -1; //记录重儿子的儿子数
    for (int i = head[x]; i; i = e[i].nex)
    {
        int y = e[i].to;
        if (y == f)
            continue;         //若为父亲则continue
        dfs1(y, x, deep + 1); // dfs其儿子
        size[x] += size[y];     //把它的儿子数加到它身上
        if (size[y] > maxson)
            son[x] = y, maxson = size[y]; //标记每个非叶子节点的重儿子编号
    }
} //变量解释见最下面
```

**DFS2**：

处理事情：

+ 标记每个点的新编号
+ 将每个点的初始值赋给新编号
+ 处理每个点所在的最顶端
+ 处理每条链

```cpp
void dfs2(int x, int topf)
{                   // x当前节点，topf当前链的最顶端的节点
    id[x] = ++cnt;  //标记每个点的新编号
    wt[cnt] = w[x]; //把每个点的初始值赋到新编号上来
    top[x] = topf;  //这个点所在链的顶端
    if (!son[x])
        return;         //如果没有儿子则返回
    dfs2(son[x], topf); //按先处理重儿子，再处理轻儿子的顺序递归处理
    for (int i = head[x]; i; i = e[i].nex)
    {
        int y = e[i].to;
        if (y == fa[x] || y == son[x])
            continue;
        dfs2(y, y); //对于每一个轻儿子都有一条从它自己开始的链
    }
} //变量解释见最下面
```

建一棵树维护它们：

```cpp
void build(int k, int l, int r)
{
    if (l == r)
    {
        t[k] = w[l];
        t[k] %= mod;
        return;
    }
    ll mid = (l + r) >> 1;
    build(k << 1, l, mid);
    build(k << 1 | 1, mid + 1, r);
    t[k] = (t[k << 1] + t[k << 1 | 1]) % mod;
}
```

**常见操作**

**修改**：从`x` 到`y` 的最短路径所有结点加上`z`

```cpp
void updRange(int x, int y, int k)
{
    k %= mod;
    while (top[x] != top[y])  //当两个点不在同一条重链
    {
        if (deep[top[x]] < deep[top[y]])
            swap(x, y);
        update(1, 1, n, id[top[x]], id[x], k);
        x = fa[top[x]];
    }
    //当两个点在同一条重链
    if (deep[x] > deep[y])
        swap(x, y);
    update(1, 1, n, id[x], id[y], k);
}
```



**查询**：求从`x`到`y`结点最短路径所有结点之和

每次查询复杂度：$O(log^2n)$

```cpp
ll qRange(int x, int y)
{
    ans = 0;
    while (top[x] != top[y]) //当两个点不在同一条链上
    {
        if (deep[top[x]] < deep[top[y]])
            swap(x, y); //把x点改为所在链顶端的深度更深的那个点
        res = 0;
        ask(1, 1, n, id[top[x]], id[x]); // ans加上x点到x所在链顶端 这一段区间的点权和
        ans += res;
        ans %= mod;     //按题意取模
        x = fa[top[x]]; //把x跳到x所在链顶端的那个点的上面一个点
    }
    //直到两个点处于一条链上
    if (deep[x] > deep[y])
        swap(x, y); //把x点变成深度更小的那个点
    res = 0;
    ask(1, 1, n, id[x], id[y]); //这时再加上此时两个点的区间和即可
    ans += res;
    ans %= mod;
    return ans % mod;
}
```



**改变子树**：更改以`x`为根节点的子树的所有子节点的和

```cpp
void updSon(int x, int k)
{
    update(1, 1, n, id[x], id[x] + size[x] - 1, k);
}
```



**求子树和**：求以`x`为根节点的子树的所有子节点的和

```cpp
ll qSon(int x)
{
    res = 0;
    ask(1, 1, n, id[x], id[x] + size[x] - 1); //子树区间右端点为id[x]+size[x]-1
    return
```



### 树上k级祖先

对一棵树求出某个结点的k级祖先。

**思路** ：类似于倍增，比如 k = 37，可以用 `k=32+4+1`的方法处理。

**预处理**

```cpp
void dfs(int u, int fa)   
{
    depth[u] = depth[fa] + 1;  //处理深度
    f[u][0] = fa;              //该节点（u）的第一个父节点就是 fa
    for (int i = 1; i <= 20; i++)
    {
        f[u][i] = f[f[u][i - 1]][i - 1];    //转移
    }
    for (auto &to : e[u])  //dfs处理
    {
        if (to != fa)
            dfs(to, u);
    }
}
```

**实现**

```cpp
int getk(int x,int k) 
{
    if(!k)         //如果k=0，说明它的0级祖先就是它本身
        return x;
    int index= log2(k);   //log2函数
    return getk(f[x][index], k - (1 << index));
}
```



### 扫描线

#### 定义

在同一个矩形内，从左往右看，第一条看到的边为“入边”，第二条看到的边为“出边”。









### 特异树形

#### 基环树

对于一棵树来说，有`n`个点，只能有`n-1`条边，但是**基环树**有`n`条边，因此形成了一个环

❓那么如何解决呢？

🌟删掉一条边！使它成为一棵树。

不断加边，并且用并查集的思想判断，如果加的那条边的两个节点在一个集合中，那么说明已经存在一个环，那么不要把这条边加进去即可，相当于删除了一条边。

```cpp
 for (int i = 1; i <= n; i++)
    {
        cin >> u >> v;
        u += 1;
        v += 1;
        if (find(u) == find(v))
        {
            S = u;
            T = v;
            continue;
        }
        add(u, v);
        add(v, u);
        fa[find(v)] = find(u);
    }
```





## 数论

### 筛法

#### 素数筛法

##### 线性筛（最快）

时间复杂度：O(n)

```cpp
int Mark[MAXSIZE];  
int prime[MAXSIZE];  

//判断是否是一个素数  Mark 标记数组 index 素数个数  
int Prime(){  
    int index = 0;  
    for(int i = 2; i < MAXSIZE; i++){  
        //如果未标记则得到一个素数  
        if(Mark[i] == 0) prime[++index] = i;  
        //标记目前得到的素数的i倍为非素数  
        for(int j = 1; j <= index && prime[j] * i < MAXSIZE; j++){  
            Mark[i * prime[j]] = 1;  
            if(i % prime[j] == 0) break;  
        }  
    }  
    return index;  
}
```



##### 欧拉筛

**时间复杂度：O(n)**

**原理**：如果判断24是否为一个素数那么用埃氏筛的话起码会重复筛24三次（2\*12，3\*8，4\*6），那欧拉筛就是在此基础上只筛一次就是其最小质因数与因一个合数的乘积。

```cpp
#include <bits/stdc++.h>//欧拉筛

using namespace std;
bool A[100000001];
int prime[1000001];

int main() {
    int n, m;
    scanf("%d %d", &n, &m);
    int cnt = 0;
    for (int i = 2; i <= n; i++) {
        if (A[i] == false) {
            prime[++cnt] = i;
        }
        for (int j = 1; j <= cnt && i * prime[j] <= n; j++) {
            A[i * prime[j]] = true;
            if (i % prime[j] == 0) break;//最重要的一步
        }
    }
    for (int i = 0; i < m; i++) {
        int c;
        scanf("%d", &c);
        printf("%d\n", prime[c]);
    }
    return 0;
}
```





### 整除相关

#### Pollard-Rho算法

用于对大数进行质因数分解，时间复杂度为`O()`









#### 欧拉函数

对正整数n，欧拉函数 $φ(n)$ 是小于n的正整数中与n互质的数的数目。

```cpp
typedef long long ll;
ll Eular(ll n)
{
    ll ans=n;
    for(int i=2; i*i <= n; ++i)
    {
        if(n%i == 0)
        {
            ans = ans/i*(i-1);
            while(n%i == 0)
                n/=i;
        }
    }
    if(n > 1) ans = ans/n*(n-1);
    return ans;
}
```

若n为质数，则 $φ(n) = n-1$ 



### 同余方程

#### 线性同余方程



#### 乘法逆元

**定义**

​	若**a**与**p**互质 a * b = 1 (mod p) --> a与b的乘积在模p时恒等于1，则b是a在模p情况下的逆元

​	可以根据乘法逆元，将 (a / b) % c 转化为 (a * x) % c ，将除法转化为乘法。

**解法**

**费马小定理**

​	假如p是质数，且$gcd(a,p)=1$，那么 $a^ {p-1}≡1(mod p)$ 。

​	根据费马小定理，a 的逆元即为 $a^{p-2}$

```cpp
需要结合快速幂
ll fpm(ll x, ll power, ll mod) {
    x %= mod;
    ll ans = 1;
    for (; power; power >>= 1, (x *= x) %= mod)
    	if(power & 1) (ans *= x) %= mod;
    return ans;
}
int main() {
	ll x = fpm(a, p - 2, p); //x为a在mod p意义下的逆元
}
```



**扩展欧几里得定理**

​	必存在 x y ，满足等式 a*x + b*y = gcd(a,b)  因此，若gcd(a,b)=1，则可以求乘法逆元

可递归得出结论：` x = y' ,y = x'- a/b * y'`

```cpp
void exgcd(ll a, ll b, ll &x, ll &y)
{
    if (!b) //递归到特解开始回溯
    {
        x = 1;
        y = 0;
        return;
    }
    exgcd(b, a % b, x, y); //求得x2,y2
    ll temp = x;
    x = y;                  //回溯，利用x2递推x1
    y = temp - (a / b) * y; //回溯，利用y2递推y1
}
int main()
{
    ll a, b, x, y;
    cin >> a >> b;
    exgcd(a, b, x, y);
    cout << x << ' ' << y << endl;
    return 0;
}
```

**递推公式**

从一到n的逆元：

这个式子必须从1开始递推

![image.png](https://s2.loli.net/2022/08/20/MLnIpJgbjHkRP7Y.png)





#### 中国剩余定理(CRT)

> 被3除剩2，被5除剩3，被7除剩2，问该数为多少？

类似于这样的问题的解法称为**中国剩余定理**

**解法**

+ 找出三个数：从 3 和5 的倍数找出除

**扩展中国剩余定理（EXCRT）** ：





#### 高次同余方程



### 博弈论

**奇异局势**:会造成后手必胜的局势。

**纳什均衡**：我们只能选择对自己最好的局面，因为无法知道别人会怎么走。（自私地把命运掌握在自己手里）

#### Bash 博弈

1堆石子有n个，每次最多取`m`个，最少1个

**奇异局势**：`(m+1)`

+ `n = m + 1`,那么后者必胜
+ `n = (m+1) * r + s`，先手取**s**个，必胜。
+ `n = r * ( m + 1 )`，先手必败

#### Nimm 博弈

有n堆石子，每堆石子数量为$a_1,a_2,a_3...$ ,轮流挑一堆取至少一个石子，取完者获胜

**奇异局势** ：`(m,m)`

+ `n = 1 `，先手全拿，先手必胜
+ `n = 2`
  + `(m,m)`：先手必输，后手只需与先手进行相同的操作
  + `(m,M)`：先手从一堆中取`(M-m)` 个，此时后手面对`(m,m)`局面，必输
+ `n = 3`
  + `(m,m,M)` 先手必胜，只需取走M个，剩下`(m,m)`
  + `(a1,a2,a3)`：异或结果为0则先手必输，否则必胜



#### Wythoff 博弈

有两堆若干个物品，两人轮流从任一堆取至少一个或同时从两堆中取走相同多的物品，每次至少取一个，取完胜利。

**奇异局势**：`(1,2)` 

```tex
//规律
0,0
1,2
3,5
4,7
6,10
8,13
9,15
11,18
```

差值是递增的，0,1,2,...n

```cpp
//隐藏规律
a = floor((b-a)*1,618)
```





### 概率与期望

**期望**：设一个离散型随机变量 x*x* 所有可能的取值分别为 $x_1,x_2,x_3,...,x_n$，这些值的对应概率是 $p_1,p_2,p_3,...,p_n$，则$E(x)=x_1p_1+x_2p_2+...+x_np_n$ 叫做这个**离散型随机变量 x的均值**或**数学期望**（简称**期望**）







### 组合数学

#### Lucas



#### 卡特兰数



#### 斯特林数







#### 容斥原理

[博客](https://blog.csdn.net/AGNING/article/details/105371507?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166062540216780357250140%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166062540216780357250140&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-105371507-null-null.142^v40^pc_rank_34_2,185^v2^control&utm_term=容斥原理&spm=1018.2226.3001.4187)

**概念**

[![vsYttx.png](https://s1.ax1x.com/2022/08/20/vsYttx.png)](https://imgse.com/i/vsYttx)

要把1-n中2、3、5的倍数全部筛掉，那么先筛2的倍数，再筛3的倍数，再筛5的倍数，这样的话6、10、15的倍数就被筛了两遍，30的倍数就被筛了三遍。因此，只要减去6、10、15的倍数，但是这样一减，30的倍数又被减了3遍，也就是说，30的倍数没有被加过，所以再加上就可以了。

容斥原理可以用来求1-n中的所有质数。

**实现**

先分解质因子：

```cpp
 for (int i = 2; i * i <= k; i++) {
        if (k % i == 0) {
            p[++tail] = i;  //p就是储存质因子的数组
            while (k % i == 0) k /= i;  //把k中所有i的质因子全部除去
        }
    }
    if (k > 1) p[++tail] = k;  //最后如果大于一，则最后一个数一定是质因子，这一步可能有一点难理解，可以多想想
```

再实现容斥：

```cpp
long long fun(long long x){
    long long res=0;  //记录1-x中与k不互质的数量
    for(int i=1;i<(1<<tail);i++){  //这里的1<<tail是指2的tail次方，表示tail个质因子有多少种组合情况 
        long long cur=1,cnt=0;  //cur表示在当前选中的质因子中的乘积，cnt表示当前选中的数量是奇数还是偶数 
        for(int j=0;j<tail;j++){  //这个循环是枚举tail的二进制形式 
            if((i>>j)&1){  //这个是判断i的第j位是不是1，如果是则表示选中第j个数 
                cnt++;  //表示选中了几个数，每选中一个就加一 
                cur*=p[j+1];  //选中第j个数就用cur乘以第j个质因子数，注意质因子数组是从1开始的，所以要加一 
            }
        }
        if(cnt&1) res+=x/cur;  //如果cnt是偶数就相加 
        else res-=x/cur;  //奇数就相减 
    }
    return x-res;  //res储存的是1-x中与K不互质的数量，所以要用x-res得到互质的数量 
}


```



### 线性代数

#### 高斯消元法





#### 线性基

**定义**

线性基是一个**数的集合**，每个序列至少有一个线性基，从线性基中取若干个数异或可以得到原序列中的任何一个数。

**性质**

+ 原序列里面的任意一个数都可以由线性基里面的一些数异或得到
+ 线性基里面的任意一些数异或起来都不能得到 0 
+ 线性基里面的数的个数唯一，并且在保持性质一的前提下，数的个数是最少的

**求法**

具体构造方法：

若要插入一个数`x`，这个x最高位为`d`

那么有两种情况，一个是`d`位还未插入值，那就直接插入`x`

另一个是已经有值了，那就把`x`异或当前的值（`d[i]`），然后接下去寻找

```cpp
void add(ll x)
{
    for(int i=60;i>=0;i--)
    {
        if(x&(1ll<<i))//注意，如果i大于31，前面的1的后面一定要加ll
        {
            if(d[i])x^=d[i];
            else
            {
                d[i]=x;
                break;//插入成功就退出
            }
        }
    }
}
```



### 多项式

[博客](https://blog.csdn.net/juruo_hejiarui/article/details/108563218)

#### FFT-快速傅里叶变换



### 莫比乌斯反演







### 数值方法

#### 三分法

假设题意求单峰函数的最值点，那么每次取两个点：`x = (2*l+r)/3` , `y = l+(2*r)/3` 

若只有最大值，则 分为两种情况

+ `f(x)>f(y)` ，舍弃$[y,r]$

+ `f(x)<f(y)`，舍弃$[l,x]$

![image.png](https://s2.loli.net/2022/08/15/vOA3olE6s7IFRak.png)

```cpp
while (abs(r - l) > exp) {
        double x = (2 * l + r) / 3, y = (l + 2 * r) / 3;
        if (f(x) < f(y)) {
            l = x;
        } else {
            r = y;
        }
    }
```



#### 自适应辛普森法





### 康托展开

**定义** ：给定自然数排列，求出由小到大中所有排列的该排列序号

![](https://i.bmp.ovh/imgs/2022/08/19/8b20cd5cf04fcce4.png)

以下是O(n^2)做法，可用树状数组存tmp，将时间复杂度降低到O(nlogn)


```cpp
void jiecheng(int x)
{
    f[0]= f[1] =1;
    for(int i = 2; i <= n; i++) f[i] = f[i - 1] * i;
}
int kangtuo()
{
    int ans =1;
    int len = str.length();
    
    for(int i=0;i<len;i++)
    {
        int tmp =0;
        for(int j=i+1;j<len;j++)
        {
            if(str[i]>str[j]) tmp++;
        }
        ans+=tmp*f[len-i+1];
    }
    return ans;
}
```



#### 逆展开

**定义** ：给定一个序号，求出对应的自然数排列

```cpp
void jie_cheng(int n)
{
    f[0] = f[1] = 1; // 0的阶乘为1
    for(int i = 2; i <= n; i++) f[i] = f[i - 1] * i;
}

vector<char> vec; //存需要排列的字符
void rev_kangtuo(int k) //输出序号为 k 的字符序列
{
    int n = vec.size(), len = 0;
    string ans = "";
    k--; // 算的时候是按 12345 是第0位
    for(int i = 1; i <= n; i++){
        int t = k / f[n - i]; // 第 i 位需要 第 t + 1 大的数
        k %= f[n - i];        //剩下的几位需要提供的排列数
        ans += vec[t] ; //  vec[t] 就是第 t + 1 大的数
        vec.erase(vec.begin() + t); 
//用过就删了，不用vector用暴力也可以，就是说枚举，然后一个一个的比较大小，并记录有几个没用过的字符且字典序比它小
    }
    cout << ans << '\n';
}
```





### 欧拉定理

**定义** ：对任意两个正整数a,n，若两者互质，则$a^{φ(n)}≡1(mod n)$

​	可用于降幂操作。

#### 前置知识

欧拉函数

#### 扩展欧拉定理

![](https://i.bmp.ovh/imgs/2022/08/19/dee20be7eed215b7.png)

##### 应用范围

扩展欧拉定理适用于模数较小，指数较大的情况下，进行降幂操作。

+ 配合大数取余求解

e.g. 给定 a,m,b， 求 $a^b mod\ m$ 



### 扩展欧几里得定理

#### 应用

##### 二元一次不定方程





## 计算几何

### 凸包

什么是**凸包**？

[![vHEPTe.png](https://s1.ax1x.com/2022/09/06/vHEPTe.png)](https://imgse.com/i/vHEPTe)



**关键知识**：

+ 极角排序：选取一个最左的点，按y最小，其次x最小来定义，接下来所有的点针对该点的射线，按角度由小到大，若相同按距离由近到远来排序。
+ 左转判定：利用叉积。对于向量p1(x1,y1),p2(x2,y2)如果x1*y2-x2*y1>0,则从p1到p2左转。

**求解方法** ---  `Graham扫描法`

一、在输入过程中找到最左下的点`a`

二、将其他所有的点对a点进行**极角排序**

三、依次进行判定，如果满足左转，那么就加入，否则如果右转或者在同一条直线上，那么就把之前的点退出，直到满足条件

```cpp
struct Point
{
    double x;
    double y;
} a[maxn], s[maxn];
double d(Point p1,Point p2)//两点间距离。。。 
{
    return sqrt((p2.y-p1.y)*(p2.y-p1.y)+(p2.x-p1.x)*(p2.x-p1.x));
}
double check(Point a1, Point a2, Point b1, Point b2)
{
    return (a2.x - a1.x) * (b2.y - b1.y) - (b2.x - b1.x) * (a2.y - a1.y);
} // 大于0则 b在 a 的上方， 小于0 就是 b 在 a 的下方
bool cmp(Point p, Point q)  //极角排序
{
    double tmp = check(a[1], p, a[1], q);
    if (tmp > 0)
        return 1;
    if (tmp == 0 && d(a[0], p) < d(a[0], q))
        return 1;
    return 0;
}
int main()
{
    cin >> n;
    cin >> a[1].x >> a[1].y;
    for (int i = 2; i <= n; i++)
    {
        cin >> a[i].x >> a[i].y;
        if (a[i].y < a[1].y)
            swap(a[i], a[1]);
        else if (a[i].y==a[1].y && a[i].x<a[1].x)
            swap(a[1], a[i]);
    }
    sort(a + 2, a + n + 1, cmp);
    s[++top] = a[1];
    double ans = 0;
    for (int i = 2; i <= n; i++)
    {
        while (top > 1 && check(s[top - 1], s[top], s[top], a[i]) <= 0)
            top--;
        s[++top] = a[i];
    }
    s[top + 1] = a[1];
    for (int i = 1; i <= top; i++)
    {
        ans += d(s[i], s[i + 1]);
    }
    printf("%.2lf", ans);
}
```





### 旋转卡壳

**应用**：

+ 计算距离
  - 凸多边形直径
  - 凸多边形宽
  - 凸多边形间最大距离
  - 凸多边形间最小距离
+ 外接矩形
  - 最小面积外接矩形
  - 最小周长外接矩形



#### 凸包直径

[![vHZ8s0.png](https://s1.ax1x.com/2022/09/06/vHZ8s0.png)](https://imgse.com/i/vHZ8s0)



先求出最上面和最下面的点之间的距离，分别在两个点作水平线，再不断旋转，分别算出遇到的对踵点的距离，求出最大值即可。

```cpp
//预先做一次凸包操作，形成一个凸包，然后sol

int sol()
{
    if (top == 1)
        return 0;
    if (top == 2)
        return d(s[1], s[2]);
    int v = 2;
    int ans = 0;
    for (int i = 1; i <= top; ++i)
    {
        while (check(s[i], s[i + 1], s[i + 1], s[v]) <= check(s[i], s[i + 1], s[i + 1], s[v + 1]))
            v = v == top ? 1 : v + 1;
        ans = max(ans, max(d(s[i], s[v]), d(s[i + 1], s[v])));
    }

    return ans;
}
```





### 半平面交
