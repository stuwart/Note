## 题单

+ [基础算法](https://www.luogu.com.cn/training/2929)
+ [拓展模板](https://www.luogu.com.cn/training/2650)
+ [提高数据结构](https://www.luogu.com.cn/training/2649)
+ [进阶数据结构](https://www.luogu.com.cn/training/3367#information)
+ [DP基础](https://www.luogu.com.cn/training/5011)
+ [动态规划提高](https://www.luogu.com.cn/training/12927)
+ [动态规划综合](https://www.luogu.com.cn/training/1435#information)
+ [数论](https://www.luogu.com.cn/training/3135#information)
+ [图论模板](https://www.luogu.com.cn/training/3364)
+ [提高图论](https://www.luogu.com.cn/training/4969)
+ [思维题](https://www.luogu.com.cn/training/4865#problems)
+ [综合](https://www.luogu.com.cn/training/9391)



## 基础算法

### 素数筛法



#### 线性筛（最快的筛法）

时间复杂度：O(n)

```cpp
int Mark[MAXSIZE];  
int prime[MAXSIZE];  

//判断是否是一个素数  Mark 标记数组 index 素数个数  
int Prime(){  
    int index = 0;  
    for(int i = 2; i < MAXSIZE; i++){  
        //如果未标记则得到一个素数  
        if(Mark[i] == 0) prime[++index] = i;  
        //标记目前得到的素数的i倍为非素数  
        for(int j = 1; j <= index && prime[j] * i < MAXSIZE; j++){  
            Mark[i * prime[j]] = 1;  
            if(i % prime[j] == 0) break;  
        }  
    }  
    return index;  
}


```



#### 欧拉筛

**时间复杂度：O(n)**

**原理**：如果判断24是否为一个素数那么用埃氏筛的话起码会重复筛24三次（2\*12，3\*8，4\*6），那欧拉筛就是在此基础上只筛一次就是其最小质因数与因一个合数的乘积。

```cpp
#include <bits/stdc++.h>//欧拉筛
using namespace std;
bool A[100000001];   int prime[1000001];
int main(){
    int n,m; scanf("%d %d",&n,&m);
    int cnt=0;
    for(int i=2;i<=n;i++){
        if(A[i]==false){
            prime[++cnt]=i;
        }
        for(int j=1;j<=cnt&&i*prime[j]<=n;j++){
            A[i*prime[j]]=true;
            if(i%prime[j]==0) break;//最重要的一步
        }
    }
    for(int i=0;i<m;i++){
        int c; scanf("%d",&c);
        printf("%d\n",prime[c]);
    }
    return 0;
}

```



### 快速幂

最快的快速幂算法，运用了位运算大大加快运算速度。

```cpp
long long fastPower(long long base, long long power) {
    long long result = 1;
    while (power > 0) {
        if (power & 1) {//此处等价于if(power%2==1)
            result = result * base ;
        }
        power >>= 1;//此处等价于power=power/2
        base = (base * base) ;
    }
    return result;
}
```



### 矩阵快速幂

**先修知识：线性代数  （狗头）**

时间复杂度：$O(log_2k)$ 

```cpp
struct matrix
{
    int n,m;   
    int e[105][105];
}
matrix a,b;

matrix mul(matrix a,matrix b)
{
    matrix ans;
    ans.n=a.n;
    ans.m=b.m;
    
    for(int i=1;i<=ans.m;i++)
   		for(int j=1;j<=ans.m;j++)
            ans.e[i][j]=0;     //初始化
    
    for(int i=1;i<=a.n;i++)
        for(int j=1;j<=b.m;j++)
            for(int k=1;k<=a.m;k++)
                ans.e[i][j]=(ans.e[i][j]+(a.e[i][k]*b.e[k][j])%mod)%mod;//快速幂的取模就在这里了！
    return ans;
}

matrix power(matrix a,ll b)
{
    matrix ans;
    ans.n=a.n;
    ans.m=a.m;
    //初始化为单元矩阵
    for(int i=1;i<=ans.n;i++)
    	for(int j=1;j<=ans.m;j++)
            if(i==j) 
                ans.e[i][j]=1;
    		else 
                ans.e[i][j]=0;    
    
    while(b)
    {
        if(b&1)
            ans=mul(ans,a);
       	a=mul(a,a);
        b>>=1;
    }
    return ans;
}
```



### 三分法

假设题意求单峰函数的最值点，那么每次取两个点：`x = (2*l+r)/3` , `y = l+(2*r)/3` 

若只有最大值，则 分为两种情况

+ `f(x)>f(y)` ，舍弃$[y,r]$

+ `f(x)<f(y)`，舍弃$[l,x]$

![image.png](https://s2.loli.net/2022/08/15/vOA3olE6s7IFRak.png)

```cpp
while (abs(r - l) > exp) {
        double x = (2 * l + r) / 3, y = (l + 2 * r) / 3;
        if (f(x) < f(y)) {
            l = x;
        } else {
            r = y;
        }
    }
```





### 字符串算法

#### KMP字符串匹配

+ 用一个nex数组维护 最长的 前缀与后缀相同的子串（最大为 n-1 ）



#### Manacher



#### Sam



#### Pam



### ST算法

**RMQ**：区间最大值/最小值查询

#### 复杂度

预处理：`O(nlogn)`

查询：`O(1)`



#### 实现

预处理，算出每个区间之间的最值。

```cpp
void init(int x)
{
  	for(int i=1;i<=n;i++)
        st[i][0]=a[i];
  	
  	for(int j=1;(1<<j)=a.length();j++)
    {
      	for(int i=1;i+(1<<(j-1))<=a.length();i++)
        {
          	st[i][j] = max(st[i][j-1],st[i+(1<<(j-1))][j-1]);
        }
    }
}
```



查询

```cpp
int Log[n+7];
void getLog()
{
	Log[1] = 0;
	for(int i=2;i<=n+1;i++)
		Log[i] = Log[i/2]+1;
}

int query(int l,int r)
{
   int k = Log(r-l+1);
   ans = max(st[l][k],st[r-(1<<k)+1][k];
   return ans;
}
```



## 数据结构

### 链表

**存储线性表的数据元素，可以是不连续的**

##### 动态链表

```c++
#初始化
struct node{
    int data;
    node *next;
};

node *head, *p, *now, *prev;

head = new node;          //定义变量
head->data = 1;          //分配第一个节点，数据置为1
head->next = NULL;  //
now = head;  //当前指针为头指针
```



##### 结构体实现链表

```c++
(单向)
struct node{
    int id;
    int nextid;
}nodes[maxn];

nodes[0].nextid = 1;
for(int i=1;i<=n;i++)
{
    nodes[i].id=i;
    nodes[i].nextid = i+1;
}
nodes[n].nextid = 1;  //循环链表

```



##### STL list

list为双向链表。

```c++
初始化
list<int> l1;  //空对象
list<int> l2(3,1); //包含3个1的对象

遍历

list<int>::iterator it = l2.begin();
while(it != l2.end())
{
    *it += 1;
    cout<<*it<<' ';
    it++;
}

范围for遍历
for(auto& e:l2)
{
    cout<<e<<' ';
}

插入
l1.push_back(xx);
l1.push_front(xx);
l1.pop_front();
l1.pop_back();

insert:
auto pos = ++l1.begin();
l1.insert(pos,5); //在pos位置前加一个5
l1.insert(pos,3,5); //在pos位置前加3个5

erase:
l1.erase(pos);   //删除pos位置元素
l1.erase(++le.begin(),--l1.end());  //删除中间内容


清空：
l1.clear();

```





### 并查集

**一种树形数据结构，用于处理不交集的合并及查询问题**

#### 创建

```c
void init(int size){
    for(int i=0;i<size;i++)
    {
        fa[i]=i;
    }
}
```



#### 查找

```c
int find(int x){
    if(fa[x]==x)
        return x;
    else
        return find(fa[x]);
}

//路径压缩版本

int find(int x){
    if(fa[x]!=x)
        fa[x]=find(fa[x]);
    return fa[x];
}
```



#### 合并

```c
viod merge(int x,int y){
    x=find(x);
    y=find(y);
    fa[x]=y;
}
```



#### 启发式合并（按秩合并）

运用于： 可持久化并查集、线段树分治 + 并查集

```c
//选择点数作为估价函数

vector<int> size(N,1);  //记录并初始化子树的大小为1

void merge(int x,int y){
    int xx = find(x);
    int yy = find(y);
    if(xx == yy) return;
    if(siez[xx] > size[yy])  // 保证小的合并到大的
        swap(xx,yy);
    fa[xx]=yy;
    size[yy]+=size[xx];
}
```





### 树状数组

#### 场景

单点修改，区间查询。



#### 复杂度

时间复杂度： 查询与修改均为 $log(n)$



**根本**：

```cpp
int lowbit(int x)   //作用：找到最后一位
{
    return x&(-x);
}
```



**求前缀和** 

```cpp
int getSum(int m){
	int ans = 0;
    while(m > 0){
        ans += C[m];
        m -= lowbit(m);
    }
    return ans;
}
```



**更新**

```cpp
void update(int x, int value){
    A[x] += value;	// 修改源数组
    while(x <= n){
        C[x] += value;
        x += lowbit(x);
    }
}

```



**示意图**：

![image.png](https://s2.loli.net/2022/07/22/9QK5rJvCuyUDms7.png)













### 线段树

#### 场景

+ 单点修改、区间修改
+ 查询区间的值



#### 操作

```cpp
int t[MAXN<<2];
```



##### 建树

```cpp
void build(int k,int l,int r)
{
    if(l==r)
        t[k] = a[i];
   	else
    {
        int m = (r-l)<<1+l;
        build(k<<1,l,m);
        build(k<<|1,m+1,r);
    }
}
```

##### 点更新

```cpp
void update(int p,int v,int k,int l,int r) //点更新
{
    if(l==r)
    {
        a[k] += v;
        t[k] += v;
    }
    else{
        int m = (r - l) / 2 + l;
        if (p <= m)
        {
            update(p, v, k << 1, l, m);
        }
        else{
            update(p, v, k << 1 | 1, m + 1, r);
        }
        Pushup(k);
    }
}
```

##### 区间更新

```cpp
void Update(int L,int R,int v,int k,int l,int r) //区间更新
{
    if(L<=l && R>=r)
    {
        t[k]+=v;
        lazy[k] += v;
    }
    else
    {
        Pushdown(k);
        int m = (r - l) / 2 + l;
        if(L<=m)
        {
            Update(L, R, v, k >> 1, l, m);
        }
        if(R>m)
        {
            Update(L, R, v, k >> 1 | 1, m + 1, r);
        }
        Pushup(k);
    }
}
```

##### 区间求最值

```cpp

ll ask(int L,int R,int k,int l,int r)   //区间查询最值
{
    if(L<=l && R>=r)
        return t[k];
    else
    {
        Pushdown(k);
        ll ans = INF;
        int m = (r - l) / 2 + l;
        if(L<=m)
            ans = max(ans, ask(L, R, k << 1, l, m));
        if(R>=m+1)
            ans = max(ans, ask(L, R, k >> 1 | 1, m + 1, r));

        return ans;
    }
}

```



##### 上升

```cpp
void pushup(int k)
{
    t[k] = t[k << 1] + t[k << 1 | 1];
}
```

##### 下降

```cpp
void pushdown(int k, int l, int r)
{
    int m = (l + r) >> 1;
    if (lazy[k] != 0)
    {
        lazy[k << 1] +=lazy[k];
        lazy[k << 1 | 1] += lazy[k];
        t[k << 1] += lazy[k] * (m - l + 1);
        t[k << 1 | 1] += lazy[k] * (r - m);
        lazy[k] = 0;
    }
}
```



### 笛卡尔树



```cpp
  for(int i=1;i<=n;i++){
        a[i]=read();
        while(a[sta[top]]>a[i]&&top) son[i][0]=sta[top--];
        if(sta[top]) son[sta[top]][1]=i;
        sta[++top]=i;
    }
    for(int i=1;i<=n;i++){
        lans=lans^(i*(son[i][0]+1));
        rans=rans^(i*(son[i][1]+1));
    }
```





## 图论



### 强连通分量

#### 定义





### 最小生成树

**定义** ：对带权**联通**无向图G，生成一棵权值最小的树。

**性质**：

+ 可能含有多个最小生成树，但是最小权值之和唯一。
+ 边数=点数 - 1



#### Prim

**思想** ：从一个顶点开始构建，每次将花费最小的新顶点加入，直到所有顶点都加入。

**时间复杂度** ：$O(\mid V \mid ^2)$   ，适用于稠密图

```cpp
//Prim
int maxn;  //最大结点数
int INF = 1000000000;
int dis[maxn]; //顶点与集合中任一点的最短距离
bool vus[maxn]; //是否已加入
int Prim()
{
    fill(dis,dis+maxn,INF);   //初始化dis数组为INF
    dis[0]=0;   //选择0号结点加入，则只有0号节点距离为0
    int ans = 0;  //由于一开始只有一个结点，没有边，所以边权之和为0
    for(int i=0;i<n;i++)
    {
        int u = -1;
        int minn = INF;
        for(int j=0;j<n;j++)
        {
            if(!vis[j] && dis[j]<minn)  //没被访问过且距离最短
            {
                u = j;
                minn = dis[j];
            }
        }
        if(u==-1) //没有找到
        	reutnr -1;
       	
        vis[u]=1;
        ans+=dis[u];
        for(int v = 0; v<n; v++)
        {
            if(!vis[v] && a[u][v]!=INF && a[u][v]<dis[v])
            {
                dis[v]=a[u][v];
            }
        }
    }
    
    
}
```




#### Kruskal

**思想** ：每次选择权值最小的边加入，且两个端点没有联通，直到所有结点都联通

**时间复杂度** ：$O(\textbar E \textbar log_2\textbar E \textbar)$

```cpp
//Kruskal

struct Edge{
    int u;
    int v;
    int w;
}e[maxm];
bool cmp(Edge p,Edge q)
{
    return p.w<q.w;
}

int find(int x)
{
    
    if(fa[x]!=x)
    {
        fa[x]=find(fa[x]);
    }
    return fa[x];
}

void Kruskal()
{
    sort(e+1,e+m+1,cmp);
    for(int i=1;i<=m;i++)
    {
        int faa = find(e[i].u);
        int fab = find(e[i].v);
        if(faa = fab)
            continue;
        fa[fab]=faa;
        ans+=e[i].w;
        if(++cnt == n-1)
            break;
    }
}
```



### 最近公共祖先（LCA）

博客[链接]((https://blog.csdn.net/qq_43332980/article/details/107437070?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-107437070-blog-121195470.pc_relevant_multi_platform_featuressortv2removedup&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-107437070-blog-121195470.pc_relevant_multi_platform_featuressortv2removedup))

#### 倍增（在线）

##### 复杂度

预处理：`O(nlogn)`

单次查询：`O(logn)`

总复杂度：`O(nlogn+mlogn)`

##### 实现

采用`f[x][i]`数组来表示点 x 的第 $2^i$ 个祖先

```cpp
//预处理f数组
for(int i=1;(i<<i)<d[u];i++)
{
  	f[u][i] = f[f[u][i-1]][i-1];
}
```

```cpp
void dfs(int u,int fa) // u为当前节点,fa为父节点
{
    f[u][0] = fa;
    d[u] = d[fa]+1;

    for(int i=1;(1<<i)<=d[u];i++)
        f[u][i] = f[f[u][i-1]][i-1];    //预处理f数组

    for(int i=head[u];i!=-1;i=e[i].next){
        int v = e[i].to;
        if(v!=fa)
            dfs(v,u);
    }
}

int lca(int x,int y)
{
    if(d[x]>d[y])  //令y为更深节点
    	swap(x,y);
    
    for(int i=20;i>=0;i--){   //这里使得x与y处于同一深度
        if(d[x]<=d[y]-(1<<i))
            y=f[y][i];
    }

    //特判
    if(x==y)
        return x;
    
    for(int i=20;i>=0;i--)
    {
        if(f[x][i]==f[y][i])
            continue;              //这里是从最远的公共祖先开始找，所以需要continue
        else
            x=f[x][i],y=f[y][i];   //上跳
    }

    return f[x][0];
}


```



#### ST+RMQ(在线)

##### 复杂度

预处理：`O(logn)`

查询：`O(1)`

总复杂度：`O(nlogn+m)`

##### 原理

将一棵树转为dfs序后，也就是说dfs序的一段区间是原树的一棵子树。

而要查找两个点的最近公共祖先，只要找dfs序中两个点之间深度最小的那个点即可。

```cpp
void getLog()
{
	Log[1] = 0;
	for(int i=2;i<=MAX_N*2;i++)
		Log[i] = Log[i/2]+1;
}
void init()   //预处理ST表
{
    for(int i=1;i<=tot;i++){
        st[0][i]=d[i];
        ist[0][i] = dfn[i];
    }
    for(int j=1;(1<<j)<=tot;j++){
		for(int i=1;i+(1<<(j-1))<=tot;i++){
            if(st[j-1][i]<st[j-1][i+(1<<(j-1))]){
                st[j][i] = st[j-1][i];
                ist[j][i] = ist[j-1][i];
            }else{
                st[j][i] = st[j-1][i+(1<<(j-1))];
                ist[j][i] = ist[j-1][i+(1<<(j-1))];
            }
        }
    }

    getLog();
}

int Query(int l,int r)
{
	int k=Log[r-l+1];
	int ans;

    if(st[k][l]<st[k][r-(1<<k)+1]) 
        ans = ist[k][l];
    else 
        ans = ist[k][r-(1<<k)+1];

    return ans;
}

void dfs(int u,int dep) // u为当前节点,dep为深度
{
    fir[u] = ++tot;
    dfn[tot] = u;
    d[tot] = dep;

    for(int i=head[u];i!=-1;i=e[i].next){
        int v = e[i].to;
        if(!fir[v]){
            dfs(v,dep+1);
            dfn[++tot]=u;
            d[tot]=dep;
        }
    }
}

int lca(int x,int y)
{
    int l = fir[x] , r = fir[y];
    if(l>r) swap(l,r);
    return Query(l,r);
}
```

#### Tarjan（离线）

##### 思路

+ 任选一个点u为根节点，开始遍历
+ 遍历所有的子节点v，并进行标记
+ 若有子节点v还有子节点，那么重复第二步，继续遍历
+ 合并v到u上（使用并查集）
+ 寻找与u有关系的查询节点v
+ 若v已被访问过，则可以直接求出LCA，即为v被合并到的父亲结点

```cpp
Tarjan(u)//marge和find为并查集合并函数和查找函数
{
    for each(u,v)    //访问所有u子节点v
    {
        Tarjan(v);        //继续往下遍历
        marge(u,v);    //合并v到u上
        标记v被访问过;
    }
    for each(u,e)    //访问所有和u有询问关系的e
    {
        如果e被访问过;
        u,e的最近公共祖先为find(e);
    }
}
```

```cpp
void Tarjan(int u,int fa) // u为当前节点,fa为父节点
{

    for(int i=head[u];i!=0;i=e[i].next){
        int v = e[i].to;
        if(v!=fa&&!vis[v]){
            Tarjan(v,u);
            unionn(u,v);   // 注意这里位置不能交换， 原树上u为v的父节点
            vis[v]=true;   // 标记访问
        }
    }

    for(int i=que[u];i!=0;i=q[i].next){
        int v = q[i].to;
        if(!q[i].flag&&vis[v]){
            ans[q[i].num] = find(v);
            q[i].flag = true;           //完成询问则把镜像问题也打上标记
            q[q[i].same].flag = true;
        }
    }
}

```









### 树链剖分

#### 使用场景

+ 从子节点到根结点到路程中 操作
+ 从根节点到其所有子节点 操作

概念：**重儿子** --- 一个节点中子树最大的儿子。

**寻找重儿子**

```cpp
void dfs_getson(int x)
{
  	size[x] = 1;
  	for(int i = head[x];i; i = e[i].nex)
    {
      int v = e[i].to;
      if(v == fa[x]) continue; //不能往回走
      fa[v] = x; 
      deep[v] = deep[x] + 1; //记录父亲和深度
      dfs_getson(v);
      size[x]+=size[v];
      if(size[v]>size[son[x]]) 
        son[x]=v; //更新重儿子
    }
}
```

**将寻找到的重儿子连接起来，成为重边**

```cpp
void dfs_rewrite(int x,int tp)//当前点以及当前点所在重链的顶端
{
    top[x]=tp;  //更新每个点所在的重链的顶端 
    id[x]=++cnt;//得到每个点的dfs序（新编号） 
    rk[tot]=x;  //记录每个新编号对应的原来的点 
    if(son[x])
      dfs_rewrite(son[x],tp);//优先往重儿子那里走 
    for(int i=head[x];i;i=e[i].next)
    {
        int v=e[i].to;
        if(v!=son[x] && v!=fa[x])
          dfs_rewrite(v,v);
    }
    ctr[x]=tot; //作用后面会讲 
}
```















### 单源最短路径


#### Floyd

**思想** ：枚举

时间复杂度：$O(n^3)$   ，    空间复杂度： $O(n^2)$

**适用条件** ： 不能有负环，且必须存在最短路

```c++
for(int k = 1; k <= n; k++){
    for(int x = 1; x <= n; x++){
        for(int y = 1; y <= n; y++){
            f[x][y]= min(f[x][y], f[x][k]+f[k][y]);
        }
    }
}
```



#### Dijkstra

**思想** ：类似于 Prim ，不断找到耗费最小的点，进行标记，直到达到目标

时间复杂度： $O(n^2)$    ，  空间复杂度： $O(m log m)$

```c++
const int inf=0x3f3f3f3f; //代表无穷大。
const int maxn=100;//最大顶点数
int n,m;//n个顶点，m条边。
bool visited[maxn];//判断是否确定到源点的最终最短距离。
int graph[maxn][maxn];//带权图
int dis[maxn];//顶点到源点的最短距离。
int start,goal;//起点与目标点。


void init(){
	memset(visited,false,sizeof(visited));
	for(int i=1;i<=n;i++){
		dis[i]=graph[start][i];//初始化dis数组。
	}
}


void dijkstra(){
	//源点为源点start。
	int minn;//记录每趟最短路径中最小的路径值。 
	int pos;//记录得到的minn所对应的下标。
	init();//调用初始化函数。
	visited[start]=true;
	for(int i=1;i<=n;i++){
		//将n个顶点依次加入判断。
		minn=inf;
		for(int j=1;j<=n;j++){
			if(!visited[j]&&dis[j]<minn){
				minn=dis[j];
				pos=j;
			}
		}
		//经过这趟for循环后我们找到的就是我们想要的点，可以确定这点到源点的最终最短距离了。
		visited[pos]=true;//我们将此点并入已知集合。
		//接下来就是更新dis数组了，也就是当前最短距离，这都是针对还没有并入已知集合的点。
		for(int j=1;j<=n;j++){
			if(!visited[j]&&dis[j]>dis[pos]+graph[pos][j])
				dis[j]=dis[pos]+graph[pos][j];
		}
	}
	//退出循环后，所有的点都已并入已知集合中，得到的dis数组也就是最终最短距离了。
	cout<<dis[goal]<<endl;//输出目标点到源点的最短路径长度。
}

```





#### Dijkstra（优先队列）

**思想** ：利用最小堆维护最小值，不用再去循环枚举找出最小值。

**时间复杂度**：$MlogM$

```cpp
typedef pair<int,int> pdd;

int head[maxn], dis[maxn];
bool vis[maxn];

struct Edge{
    itn u,v,w;
    int nex;
}e[maxm];

inline void add(int a,int b,int c)
{
    e[++cnt].u=a;
    e[cnt].v=b;
    e[cnt].w=c;
    e[cnt].nex=head[a];
    head[a]=cnt;
}

priority_queue<pdd,vector<pdd>,greater<pdd>> q;

void dijkstra()
{
    while(!empty())
    {
        pdd t = q.top();
        q.pop();
        int now = t.second;
        if(vis[now])
            continue;
        vie[now]=true;
        
        for(int i = head[now]; i; i = e[i].nex)
        {
            int to = e[i].v;
            if(dis[to]>dis[now]+e[i].w)
            {
                dis[to]= dis[now] + e[i].w;
                q.push({dis[to],to});
            }
        }
    }
    
}
```







## 数论

### 康托展开

**定义** ：给定自然数排列，求出由小到大中所有排列的该排列序号

![image.png](https://s2.loli.net/2022/08/11/4nsyCXZdhertqjD.png)

以下是O(n^2)做法，可用树状数组存tmp，将时间复杂度降低到O(nlogn)


```cpp
void jiecheng(int x)
{
    f[0]= f[1] =1;
    for(int i = 2; i <= n; i++) f[i] = f[i - 1] * i;
}
int kangtuo()
{
    int ans =1;
    int len = str.length();
    
    for(int i=0;i<len;i++)
    {
        int tmp =0;
        for(int j=i+1;j<len;j++)
        {
            if(str[i]>str[j]) tmp++;
        }
        ans+=tmp*f[len-i+1];
    }
    return ans;
}
```



#### 逆展开

**定义** ：给定一个序号，求出对应的自然数排列

```cpp
void jie_cheng(int n)
{
    f[0] = f[1] = 1; // 0的阶乘为1
    for(int i = 2; i <= n; i++) f[i] = f[i - 1] * i;
}

vector<char> vec; //存需要排列的字符
void rev_kangtuo(int k) //输出序号为 k 的字符序列
{
    int n = vec.size(), len = 0;
    string ans = "";
    k--; // 算的时候是按 12345 是第0位
    for(int i = 1; i <= n; i++){
        int t = k / f[n - i]; // 第 i 位需要 第 t + 1 大的数
        k %= f[n - i];        //剩下的几位需要提供的排列数
        ans += vec[t] ; //  vec[t] 就是第 t + 1 大的数
        vec.erase(vec.begin() + t); 
//用过就删了，不用vector用暴力也可以，就是说枚举，然后一个一个的比较大小，并记录有几个没用过的字符且字典序比它小
    }
    cout << ans << '\n';
}
```



### 乘法逆元

#### 定义 

​	若 a * b = 1 (mod p) --> a与b的乘积在模p时恒等于1，则b是a在模p情况下的逆元

​	可以根据乘法逆元，将 (a / b) % c 转化为 (a * x) % c ，将除法转化为乘法。

#### 解法

##### 费马小定理

​	假如p是质数，且gcd(a,p)=1，那么 $a^ {p-1}≡1(mod p)$ 。

​	根据费马小定理，a 的逆元即为 $a^{p-2}$

##### 扩展欧几里得定理

​	若gcd(a,b) = 1, 则必存在 x y ，使得 a*x + b*y = 1. 





### 欧拉定理

**定义** ：对任意两个正整数a,n，若两者互质，则$a^{φ(n)}≡1(mod n)$

​	可用于降幂操作。

#### 前置知识

欧拉函数：对正整数n，欧拉函数 $φ(n)$ 是小于n的正整数中与n互质的数的数目。

```cpp
typedef long long ll;
ll Eular(ll n)
{
    ll ans=n;
    for(int i=2; i*i <= n; ++i)
    {
        if(n%i == 0)
        {
            ans = ans/i*(i-1);
            while(n%i == 0)
                n/=i;
        }
    }
    if(n > 1) ans = ans/n*(n-1);
    return ans;
}
```

若n为质数，则 $φ(n) = n-1$ 

#### 扩展欧拉定理

![image.png](https://s2.loli.net/2022/08/10/wL49lD1anNfXFoS.png)

##### 应用范围

扩展欧拉定理适用于模数较小，指数较大的情况下，进行降幂操作。

+ 配合大数取余求解

e.g. 给定 a,m,b， 求 $a^b mod\ m$ 
<<<<<<< HEAD

=======
>>>>>>> Mac



